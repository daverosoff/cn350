var ptx_lunr_search_style = "textbook";
var ptx_lunr_docs = [
{
  "id": "colophon-1",
  "level": "1",
  "url": "colophon-1.html",
  "type": "Colophon",
  "number": "",
  "title": "Colophon",
  "body": "   example.org   https:\/\/example.org   copyright  "
},
{
  "id": "sec-proofs",
  "level": "1",
  "url": "sec-proofs.html",
  "type": "Section",
  "number": "1.1",
  "title": "Proofs",
  "body": " Proofs          Class Activities      Negate the following statement:   Choose the correct statement:   Mike is not tall, or Karen is not tall    Mike is tall, or Karen is tall    Mike is not tall, and Karen is not tall    Mike is tall, and Karen is tall     Let be the statement Let be the statement First, translate the statement into formal logic. In this statement, is true, and is true. Therefore, the correct answer is  and  , or . Now, negate the statement.  Thus, the answer is Recall what and represent:  From , we get           Buttercup knows whether or not Westley is lying. She promises that if Westley is lying, she will give you a cookie. Buttercup always keeps her promises.  Suppose she does not give you a cookie; what can you conclude?    Westley is lying.    Westley is not lying.    Not enough information to determine.    Suppose she gives you a cookie; what can you conclude?    Westley is lying.    Westley is not lying.    Not enough information to determine.                        Negate the following statement:     Write the statement in formal logic:               Negate the logic:               Rewrite the negated logic in English   Mary does not fail her classes or she cannot graduate    Mary does not fail her classes and she cannot graduate    Mary does not fail her classes and she can graduate    Mary fails her classes and she can graduate       In this statement, if is true, then is false. This is an relationship. Thus, the answer is Now, negate the statement. In order to negate this statement, first translate it into an statement to get rid of the operator.   Thus, the answer is Recall what and represent:  From , we get           Negate the following statement.     Choose the correct statement:                  First, translate the statement into formal logic. In this statement, can be true, xor can be true, or neither can be true. The key here is that while either one can succeed, there is no guarantee of success. The expression is then equal to Now, negate the statement.   The answer is then As an extra exercise, what would this statement translate to in English?          Which of the following are equivalent to ? Select all that apply.            Which of the following are equivalent to the contrapositive of the logical expression ? Select all that apply.            We say a set is finite if there is a nonnegative integer such that the proposition is true. If is a finite set, then denotes the size of , the number of its elements.  A one-to-one correspondence or bijection is a function that can be reversed. Given a function , you can tell that is a bijection if it pairs each input (argument) to a unique output (value).    Let be a finite set. How many functions are there with domain and codomain ?  Try listing all possibilities for . A pattern should emerge. Once you think you see it, try to explain why that is the answer. The lists you made for the small examples should help you see the general case.   Establish a one-to-one correspondence (i.e., a bijection) between the set of functions and the power set .  The inputs of your bijection could be the functions and the outputs the elements of the set .   Define a function by the equation . We will show that is a bijection. Bijections are functions with two properties:   If then (no overlap\/collision; at most one inbound arrow for each codomain element)  For each in the codomain, there is in the domain such that (every codomain element covered ; at least one inbound arrow for each codomain element)   Suppose that and are distinct functions . We need to show that . The first is the subset of on which takes the value . The second is the same set, but for . Since , there is some where . Since the only possible values of these functions are and , it follows that exactly one of and is equal to . Hence is a member of or , but not both. This shows that has the first property of a bijection.  To obtain the second, let us choose an arbitrary element . This is just a subset of . We must show that there exists a function such that . We may of course define and then we see at once that has the desired property. We have now shown that has both properties of a bijection.   Conclude that , and identify the common value of these expressions. (Your answer will depend on .)  Since we have seen a bijection between these sets, they have the same size. We listed all the binary functions on variables; there are of them, so there must be subsets of as well. Observe these combine to say for every finite set .     "
},
{
  "id": "objectives-1",
  "level": "2",
  "url": "sec-proofs.html#objectives-1",
  "type": "Objectives",
  "number": "1.1",
  "title": "",
  "body": "      "
},
{
  "id": "activity-1",
  "level": "2",
  "url": "sec-proofs.html#activity-1",
  "type": "Activity",
  "number": "1.1.1",
  "title": "",
  "body": "   Negate the following statement:   Choose the correct statement:   Mike is not tall, or Karen is not tall    Mike is tall, or Karen is tall    Mike is not tall, and Karen is not tall    Mike is tall, and Karen is tall     Let be the statement Let be the statement First, translate the statement into formal logic. In this statement, is true, and is true. Therefore, the correct answer is  and  , or . Now, negate the statement.  Thus, the answer is Recall what and represent:  From , we get       "
},
{
  "id": "activity-2",
  "level": "2",
  "url": "sec-proofs.html#activity-2",
  "type": "Activity",
  "number": "1.1.2",
  "title": "",
  "body": "   Buttercup knows whether or not Westley is lying. She promises that if Westley is lying, she will give you a cookie. Buttercup always keeps her promises.  Suppose she does not give you a cookie; what can you conclude?    Westley is lying.    Westley is not lying.    Not enough information to determine.    Suppose she gives you a cookie; what can you conclude?    Westley is lying.    Westley is not lying.    Not enough information to determine.                    "
},
{
  "id": "activity-3",
  "level": "2",
  "url": "sec-proofs.html#activity-3",
  "type": "Activity",
  "number": "1.1.3",
  "title": "",
  "body": "   Negate the following statement:     Write the statement in formal logic:               Negate the logic:               Rewrite the negated logic in English   Mary does not fail her classes or she cannot graduate    Mary does not fail her classes and she cannot graduate    Mary does not fail her classes and she can graduate    Mary fails her classes and she can graduate       In this statement, if is true, then is false. This is an relationship. Thus, the answer is Now, negate the statement. In order to negate this statement, first translate it into an statement to get rid of the operator.   Thus, the answer is Recall what and represent:  From , we get       "
},
{
  "id": "activity-4",
  "level": "2",
  "url": "sec-proofs.html#activity-4",
  "type": "Activity",
  "number": "1.1.4",
  "title": "",
  "body": "   Negate the following statement.     Choose the correct statement:                  First, translate the statement into formal logic. In this statement, can be true, xor can be true, or neither can be true. The key here is that while either one can succeed, there is no guarantee of success. The expression is then equal to Now, negate the statement.   The answer is then As an extra exercise, what would this statement translate to in English?      "
},
{
  "id": "activity-5",
  "level": "2",
  "url": "sec-proofs.html#activity-5",
  "type": "Activity",
  "number": "1.1.5",
  "title": "",
  "body": "  Which of the following are equivalent to ? Select all that apply.         "
},
{
  "id": "activity-6",
  "level": "2",
  "url": "sec-proofs.html#activity-6",
  "type": "Activity",
  "number": "1.1.6",
  "title": "",
  "body": "  Which of the following are equivalent to the contrapositive of the logical expression ? Select all that apply.         "
},
{
  "id": "activity-7",
  "level": "2",
  "url": "sec-proofs.html#activity-7",
  "type": "Activity",
  "number": "1.1.7",
  "title": "",
  "body": "  We say a set is finite if there is a nonnegative integer such that the proposition is true. If is a finite set, then denotes the size of , the number of its elements.  A one-to-one correspondence or bijection is a function that can be reversed. Given a function , you can tell that is a bijection if it pairs each input (argument) to a unique output (value).    Let be a finite set. How many functions are there with domain and codomain ?  Try listing all possibilities for . A pattern should emerge. Once you think you see it, try to explain why that is the answer. The lists you made for the small examples should help you see the general case.   Establish a one-to-one correspondence (i.e., a bijection) between the set of functions and the power set .  The inputs of your bijection could be the functions and the outputs the elements of the set .   Define a function by the equation . We will show that is a bijection. Bijections are functions with two properties:   If then (no overlap\/collision; at most one inbound arrow for each codomain element)  For each in the codomain, there is in the domain such that (every codomain element covered ; at least one inbound arrow for each codomain element)   Suppose that and are distinct functions . We need to show that . The first is the subset of on which takes the value . The second is the same set, but for . Since , there is some where . Since the only possible values of these functions are and , it follows that exactly one of and is equal to . Hence is a member of or , but not both. This shows that has the first property of a bijection.  To obtain the second, let us choose an arbitrary element . This is just a subset of . We must show that there exists a function such that . We may of course define and then we see at once that has the desired property. We have now shown that has both properties of a bijection.   Conclude that , and identify the common value of these expressions. (Your answer will depend on .)  Since we have seen a bijection between these sets, they have the same size. We listed all the binary functions on variables; there are of them, so there must be subsets of as well. Observe these combine to say for every finite set .   "
},
{
  "id": "sec-induction",
  "level": "1",
  "url": "sec-induction.html",
  "type": "Section",
  "number": "1.2",
  "title": "Induction",
  "body": " Induction      Let be a subset of the natural numbers satisfying  ; and  If , then .  Then .     We usually apply the induction theorem in a highly implicit way. It is only invoked by name in introductory texts like this one. We have a sequence of theorems we wish to prove by induction. Usually we are too lazy to speak this way and we say we are proving one theorem, but about every natural number instead of a specific one (or about trees of arbitrary height instead of trees of height ). Each theorem in our sequence has a hypothesis and a conclusion . Often all of the are the same, but it doesn't hurt anything to let them be different. It happens even more often that all of the are specializations of a statement about integers to a specific integer. What we do when we write a proof by induction is to apply the induction theorem to the set defined by , that is, the set of natural numbers (or e.g. tree heights) for which our theorem holds. If we can show the hypotheses of the induction theorem apply to the set , our proof is complete, because the conclusion of the induction theorem then entails that .  This is what I meant in class when I spoke of an argument machine . As stated above, none of this framework is ever explicitly mentioned in practice. In undergraduate books, it is considered enough to mention induction, prove a base case and an induction step or inductive case (two phrases for the same thing), and voilà! The proof is complete.  Thus, the induction framework consists of arranging your argument so that the sequences and are clear. We call the theorem the base case . This theorem could also be stated as .   The inductive case is always phrased as a conditional. If  is a natural number that is in , then  is also in . If you recall the definition of , you will see that this conditional is equivalent to . So, we usually formulate our induction step in the latter way. My induction hypothesis would be implies . From this hypothesis I would attempt to deduce the conclusion, implies .  As a final thought, I should tell you that in our real writing, we don't usually assign values like to specific predicates like divides . I have done so here to aid in my clear expression, but you should try to craft your argument without using phrases like:  now let  assume  the theorem is true for      Class activities    Show, using induction, that if is a natural number, then divides .   Here is the empty statement and is the statement divides . The empty statement is indistinguishable from the logical constant .    The base case is to show that satisfies the conclusion of the statement. But , so the base case is done.  The inductive case is always phrased as a conditional. If  is a natural number that is in , then  is also in . Let us prove this statement. We will use a direct proof, assuming the hypothesis ( divides ) and deducing the conclusion ( divides ).  Since divides , the definition of divisibility tells us there is such that Multiplying this equation by 4 and adding 3, we obtain Since , we have shown that and the induction step is complete, as is the proof.      Prove that for all natural numbers , divides . Use the induction framework.    The base case is just like before. The inductive step is to prove: if divides , it also divides .  Here are some helpful facts that you can use without proof. In a math class, we'd prove these as exercises as well, but here I'm hoping to provide enough math hints that you can focus more on the logical structure of the argument and less on the arithmetic.  If divides and divides , then divides .  is even is the same statement as divides .  If divides , then divides for all integers .  If divides and divides , then divides .        In this activity we deal with points in the -dimensional Euclidean space . Such a point is specified by an -tuple of coordinates , where each .  The unit cube in , or unit -cube , is the subset of defined by   Just as a 3-dimensional cube has 2-, 1-, and 0-dimensional faces (usually called faces, edges, and corners, respectively), the -cube has faces of all lower dimensions. We are interested in the corners.  The corners of are defined to be the points of , all of whose coordinates are either 0 or 1. For example, is a corner of .    Prove that has corners using the induction framework.      The Fibonacci numbers are defined by The sequence begins .    Consider a rectangular array of squares, and the problem of determining the number of ways it may be tiled by dominoes. Each domino must cover exactly 2 adjacent squares, without overlaps. So, one way is to use all parallel dominoes. If happens to be even, all horizontal dominoes will work as well.      Of course, other tilings are also possible.     You can probably draw all 13 tilings of the grid quite easily. It turns out that 13 is also the value of , the 7th Fibonacci number. This isn't a coincidence, as you're asked to show below.  Using the recurrence relation above and the induction framework, show that there are such tilings of the array by dominoes, for all .   Note. For , we say that there is one way to tile an empty array with no dominoes. There would be zero ways to do it with more dominoes, and zero ways to tile a nonempty array with no dominoes.   Consider the ways in which a tiling of a array can arise from a smaller tiling. Remember, you need to show that the number of -tilings is the sum of the number of -tilings and the number of -tilings.   If we look at the last two columns of an -tiling, they have to either be both horizontal dominoes or both vertical. If they are both horizontal, removing both dominoes yields an -tiling. If they are both vertical, removing the last one only yields an -tiling.      What is wrong with the following argument?   (Alleged theorem)   All cars are blue.    It is enough to show that given a nonempty finite set of cars, all of them are the same color. Since mine is blue, the result will follow at once. Let us prove by induction that every nonempty finite set of cars is monochromatic. If the set has just one car, it is surely monochromatic. Now let us suppose, by way of induction, that for some positive integer it has already been shown that every set of cars is monochromatic.  Consider a set of cars. We may form sets , by deleting the th car from to form . Applying the induction hypothesis to each of the sets we see that each of these sets is monochromatic. But then is monochromatic as well, and the proof is complete.       "
},
{
  "id": "objectives-2",
  "level": "2",
  "url": "sec-induction.html#objectives-2",
  "type": "Objectives",
  "number": "1.2",
  "title": "",
  "body": ""
},
{
  "id": "thm-induction",
  "level": "2",
  "url": "sec-induction.html#thm-induction",
  "type": "Theorem",
  "number": "1.2.1",
  "title": "",
  "body": "  Let be a subset of the natural numbers satisfying  ; and  If , then .  Then .   "
},
{
  "id": "rem-induction-framework",
  "level": "2",
  "url": "sec-induction.html#rem-induction-framework",
  "type": "Remark",
  "number": "1.2.2",
  "title": "",
  "body": " We usually apply the induction theorem in a highly implicit way. It is only invoked by name in introductory texts like this one. We have a sequence of theorems we wish to prove by induction. Usually we are too lazy to speak this way and we say we are proving one theorem, but about every natural number instead of a specific one (or about trees of arbitrary height instead of trees of height ). Each theorem in our sequence has a hypothesis and a conclusion . Often all of the are the same, but it doesn't hurt anything to let them be different. It happens even more often that all of the are specializations of a statement about integers to a specific integer. What we do when we write a proof by induction is to apply the induction theorem to the set defined by , that is, the set of natural numbers (or e.g. tree heights) for which our theorem holds. If we can show the hypotheses of the induction theorem apply to the set , our proof is complete, because the conclusion of the induction theorem then entails that .  This is what I meant in class when I spoke of an argument machine . As stated above, none of this framework is ever explicitly mentioned in practice. In undergraduate books, it is considered enough to mention induction, prove a base case and an induction step or inductive case (two phrases for the same thing), and voilà! The proof is complete.  Thus, the induction framework consists of arranging your argument so that the sequences and are clear. We call the theorem the base case . This theorem could also be stated as .  "
},
{
  "id": "activity-8",
  "level": "2",
  "url": "sec-induction.html#activity-8",
  "type": "Activity",
  "number": "1.2.1",
  "title": "",
  "body": "  Show, using induction, that if is a natural number, then divides .   Here is the empty statement and is the statement divides . The empty statement is indistinguishable from the logical constant .    The base case is to show that satisfies the conclusion of the statement. But , so the base case is done.  The inductive case is always phrased as a conditional. If  is a natural number that is in , then  is also in . Let us prove this statement. We will use a direct proof, assuming the hypothesis ( divides ) and deducing the conclusion ( divides ).  Since divides , the definition of divisibility tells us there is such that Multiplying this equation by 4 and adding 3, we obtain Since , we have shown that and the induction step is complete, as is the proof.   "
},
{
  "id": "activity-9",
  "level": "2",
  "url": "sec-induction.html#activity-9",
  "type": "Activity",
  "number": "1.2.2",
  "title": "",
  "body": "  Prove that for all natural numbers , divides . Use the induction framework.    The base case is just like before. The inductive step is to prove: if divides , it also divides .  Here are some helpful facts that you can use without proof. In a math class, we'd prove these as exercises as well, but here I'm hoping to provide enough math hints that you can focus more on the logical structure of the argument and less on the arithmetic.  If divides and divides , then divides .  is even is the same statement as divides .  If divides , then divides for all integers .  If divides and divides , then divides .     "
},
{
  "id": "subsec-unit-cube",
  "level": "2",
  "url": "sec-induction.html#subsec-unit-cube",
  "type": "Activity",
  "number": "1.2.3",
  "title": "",
  "body": "  In this activity we deal with points in the -dimensional Euclidean space . Such a point is specified by an -tuple of coordinates , where each .  The unit cube in , or unit -cube , is the subset of defined by   Just as a 3-dimensional cube has 2-, 1-, and 0-dimensional faces (usually called faces, edges, and corners, respectively), the -cube has faces of all lower dimensions. We are interested in the corners.  The corners of are defined to be the points of , all of whose coordinates are either 0 or 1. For example, is a corner of .    Prove that has corners using the induction framework.   "
},
{
  "id": "activity-11",
  "level": "2",
  "url": "sec-induction.html#activity-11",
  "type": "Activity",
  "number": "1.2.4",
  "title": "",
  "body": "  The Fibonacci numbers are defined by The sequence begins .    Consider a rectangular array of squares, and the problem of determining the number of ways it may be tiled by dominoes. Each domino must cover exactly 2 adjacent squares, without overlaps. So, one way is to use all parallel dominoes. If happens to be even, all horizontal dominoes will work as well.      Of course, other tilings are also possible.     You can probably draw all 13 tilings of the grid quite easily. It turns out that 13 is also the value of , the 7th Fibonacci number. This isn't a coincidence, as you're asked to show below.  Using the recurrence relation above and the induction framework, show that there are such tilings of the array by dominoes, for all .   Note. For , we say that there is one way to tile an empty array with no dominoes. There would be zero ways to do it with more dominoes, and zero ways to tile a nonempty array with no dominoes.   Consider the ways in which a tiling of a array can arise from a smaller tiling. Remember, you need to show that the number of -tilings is the sum of the number of -tilings and the number of -tilings.   If we look at the last two columns of an -tiling, they have to either be both horizontal dominoes or both vertical. If they are both horizontal, removing both dominoes yields an -tiling. If they are both vertical, removing the last one only yields an -tiling.   "
},
{
  "id": "activity-12",
  "level": "2",
  "url": "sec-induction.html#activity-12",
  "type": "Activity",
  "number": "1.2.5",
  "title": "",
  "body": "  What is wrong with the following argument?   (Alleged theorem)   All cars are blue.    It is enough to show that given a nonempty finite set of cars, all of them are the same color. Since mine is blue, the result will follow at once. Let us prove by induction that every nonempty finite set of cars is monochromatic. If the set has just one car, it is surely monochromatic. Now let us suppose, by way of induction, that for some positive integer it has already been shown that every set of cars is monochromatic.  Consider a set of cars. We may form sets , by deleting the th car from to form . Applying the induction hypothesis to each of the sets we see that each of these sets is monochromatic. But then is monochromatic as well, and the proof is complete.     "
},
{
  "id": "DFA-intro",
  "level": "1",
  "url": "DFA-intro.html",
  "type": "Section",
  "number": "2.1",
  "title": "Examples of finite state automata",
  "body": "  Examples of finite state automata   The bank store customer model  Some stuff    The marble-rolling toy    (This example is due to HMU.) Consider the marble-rolling toy pictured below. A marble enters at either or . The path taken by the marble is determined by three levers. Lever 1 is immediately beneath A. If it points left, the marble rolls left and exits through output C. If Lever 1 points right, the marble rolls right and lands on Lever 2 (between A and B). If Lever 2 points left, the marble rolls left and exits through output C. If Lever 2 points rights, the marble rolls right and exits through output D. Finally, Lever 3 is beneath input B. If it points left, we go to Lever 2; otherwise, to output D.  Let us say that a word is accepted if, when we begin in the pictured starting configuration, rolling a marble for each symbol, the final marble exits at .   A marble-rolling toy with two input chutes labeled A and B, and two output chutes labeled C and D. The path taken by the marble is determined by three levers. Lever 1 is immediately beneath A. If it points left, the marble rolls left and exits through output C. If Lever 1 points right, the marble rolls right and lands on Lever 2 (between A and B). If Lever 2 points left, the marble rolls left and exits through output C. If Lever 2 points right, the marble rolls right and exits through output D. Finally, Lever 3 is beneath input B. If it points left, we go to Lever 2; otherwise, to output D.     Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?   Find all the words on of length at most accepted by the marble-rolling toy, assuming that a word is accepted if the last marble exits at D.   (empty word)                                  Can you describe the language accepted by the toy?      "
},
{
  "id": "objectives-3",
  "level": "2",
  "url": "DFA-intro.html#objectives-3",
  "type": "Objectives",
  "number": "2.1",
  "title": "",
  "body": ""
},
{
  "id": "act-marble-toy",
  "level": "2",
  "url": "DFA-intro.html#act-marble-toy",
  "type": "Activity",
  "number": "2.1.1",
  "title": "",
  "body": "  (This example is due to HMU.) Consider the marble-rolling toy pictured below. A marble enters at either or . The path taken by the marble is determined by three levers. Lever 1 is immediately beneath A. If it points left, the marble rolls left and exits through output C. If Lever 1 points right, the marble rolls right and lands on Lever 2 (between A and B). If Lever 2 points left, the marble rolls left and exits through output C. If Lever 2 points rights, the marble rolls right and exits through output D. Finally, Lever 3 is beneath input B. If it points left, we go to Lever 2; otherwise, to output D.  Let us say that a word is accepted if, when we begin in the pictured starting configuration, rolling a marble for each symbol, the final marble exits at .   A marble-rolling toy with two input chutes labeled A and B, and two output chutes labeled C and D. The path taken by the marble is determined by three levers. Lever 1 is immediately beneath A. If it points left, the marble rolls left and exits through output C. If Lever 1 points right, the marble rolls right and lands on Lever 2 (between A and B). If Lever 2 points left, the marble rolls left and exits through output C. If Lever 2 points right, the marble rolls right and exits through output D. Finally, Lever 3 is beneath input B. If it points left, we go to Lever 2; otherwise, to output D.     Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?   Find all the words on of length at most accepted by the marble-rolling toy, assuming that a word is accepted if the last marble exits at D.   (empty word)                                  Can you describe the language accepted by the toy?    "
},
{
  "id": "DFA",
  "level": "1",
  "url": "DFA.html",
  "type": "Section",
  "number": "2.2",
  "title": "Deterministic finite automata",
  "body": " Deterministic finite automata          Class Activities  Now you know that to specify a DFA, it is really enough to give the transition function . A transition table or transition diagram has enough information to specify the set of states, the set of symbols, the start state, and the set of accepting states.  In the reading, you have seen how a DFA is like a very simple computer, modeled by walks on a directed graph. Each move in the walk is determined by the transition function of the DFA as we consume the characters in the input string one by one.    For each pictured DFA, give a simple description of the language it accepts. Get the instructor to check before moving on.              Designing DFA  When designing a DFA or other automaton, it can be helpful to imagine yourself as the DFA and consider your cognition as you read the input word one symbol at a time. What must you remember about the string? How do you perform the DFA's task? It helps when doing this to remember that the word might be very long, so long you can't remember it all at once. You also don't know when the string will end, so you must always be ready with the answer.  Suppose that the alphabet is and we wish to accept all words with an odd number of 1s. If you start going through a long input string of 0s and 1s, one symbol at a time, do you need to see the whole string? Do you need to remember any of it? No, you simply keep track of whether the number of 1s you have seen so far is even or odd.  This gives a clue to the design of the DFA. There are two states and , corresponding to having seen an even or odd number of 1s so far. We begin in state , since at the beginning, we haven't seen any symbols and in particular have seen no 1s. Now the transitions should be clear: all transitions labeled with are self-loops, since the number of 1s does not change. Similarly, each transition labeled with changes state, because whenever we read a 1, the number of 1s seen so far changes parity.  There is just one accepting state, state , because that is the condition for having seen an odd number of 1s so far. If we are in state when the input ends, we win; otherwise, our string must be rejected.     Give diagrams or tables for DFAs accepting the following languages over the alphabet . Make sure your answers include at least one table and one diagram. Get the instructor to check before you go on.   The set of all strings with 011 as a substring.   Words on with an odd number of b    Words on that start with 000    Words on that end in 11   The set of all strings with three consecutive 0s (not necessarily at the end)       Give DFAs accepting the following languages over the alphabet :   The set of all strings beginning with a 1 such that, when is interpreted as a binary integer, it is a multiple of 3. For example, strings 11, 110, and 1111 are in the language, while 10, 100, and 111 are not.  The set of all such strings that, when interpreted in reverse as binary integers, are multiples of 3. Examples of strings in the language are 0, 00011, and 1001000. Observe there is no restriction on the leading digit in this part.     There is an interpretation with 3 states using ideas from modular arithmetic, similar to .      Make a DFA that is equivalent to the marble-rolling toy of . This will take some thought. I did it with 16 states originally, and 13 of them turned out to be accessible.      Recall that if is an automaton, we defined the extended transition function inductively for a word (where ) by However, we think informally about as describing what happens along a path with a certain string of labels. So it should not matter how we break the input string in the definition of . That is, we should be able to use any factorization , not just one with . Use induction on to prove that .    Use the induction framework elaborated in , particularly in .      Show that for any state , string , and input symbol , .    Use the result of .      Give DFAs accepting the following languages over the alphabet :   The set of all strings such that each block of 5 consecutive symbols contains at least two 0s  The set of all strings whose third symbol from the right is a 1  The set of strings that either begin or end (or both) with 01  The set of strings such that the number of 0s is divisible by 5 and the number of 1s is divisible by 3       Let be a DFA and a particular state of , such that for all . Show by induction on that for all input words .      Let be a DFA and a particular state of , such that for all .    Show by induction on that for all , , where is the string consisting of  s.    Show that either or .      We use the exponential notation for self-concatenation of words as well as individual input symbols from . For example, if then .    Let be a DFA, and suppose that for all we have .    Show that for all we have .    Show that if is a nonempty string in , then for all , then , the -fold concatenation of , is also in .        Consider the DFA with the following transition table:      0  1              Informally describe the language accepted by this DFA, and prove by induction on the length of the input that your description is correct.    When setting up the inductive hypothesis, it is wise to make a statement about what inputs get you to each state, not just what inputs get you to the accepting state.     "
},
{
  "id": "objectives-4",
  "level": "2",
  "url": "DFA.html#objectives-4",
  "type": "Objectives",
  "number": "2.2",
  "title": "",
  "body": "      "
},
{
  "id": "activity-14",
  "level": "2",
  "url": "DFA.html#activity-14",
  "type": "Activity",
  "number": "2.2.1",
  "title": "",
  "body": "  For each pictured DFA, give a simple description of the language it accepts. Get the instructor to check before moving on.            "
},
{
  "id": "par-design-dfa",
  "level": "2",
  "url": "DFA.html#par-design-dfa",
  "type": "Remark",
  "number": "2.2.1",
  "title": "Designing DFA.",
  "body": " Designing DFA  When designing a DFA or other automaton, it can be helpful to imagine yourself as the DFA and consider your cognition as you read the input word one symbol at a time. What must you remember about the string? How do you perform the DFA's task? It helps when doing this to remember that the word might be very long, so long you can't remember it all at once. You also don't know when the string will end, so you must always be ready with the answer.  Suppose that the alphabet is and we wish to accept all words with an odd number of 1s. If you start going through a long input string of 0s and 1s, one symbol at a time, do you need to see the whole string? Do you need to remember any of it? No, you simply keep track of whether the number of 1s you have seen so far is even or odd.  This gives a clue to the design of the DFA. There are two states and , corresponding to having seen an even or odd number of 1s so far. We begin in state , since at the beginning, we haven't seen any symbols and in particular have seen no 1s. Now the transitions should be clear: all transitions labeled with are self-loops, since the number of 1s does not change. Similarly, each transition labeled with changes state, because whenever we read a 1, the number of 1s seen so far changes parity.  There is just one accepting state, state , because that is the condition for having seen an odd number of 1s so far. If we are in state when the input ends, we win; otherwise, our string must be rejected.  "
},
{
  "id": "activity-15",
  "level": "2",
  "url": "DFA.html#activity-15",
  "type": "Activity",
  "number": "2.2.2",
  "title": "",
  "body": "  Give diagrams or tables for DFAs accepting the following languages over the alphabet . Make sure your answers include at least one table and one diagram. Get the instructor to check before you go on.   The set of all strings with 011 as a substring.   Words on with an odd number of b    Words on that start with 000    Words on that end in 11   The set of all strings with three consecutive 0s (not necessarily at the end)    "
},
{
  "id": "activity-16",
  "level": "2",
  "url": "DFA.html#activity-16",
  "type": "Activity",
  "number": "2.2.3",
  "title": "",
  "body": "  Give DFAs accepting the following languages over the alphabet :   The set of all strings beginning with a 1 such that, when is interpreted as a binary integer, it is a multiple of 3. For example, strings 11, 110, and 1111 are in the language, while 10, 100, and 111 are not.  The set of all such strings that, when interpreted in reverse as binary integers, are multiples of 3. Examples of strings in the language are 0, 00011, and 1001000. Observe there is no restriction on the leading digit in this part.     There is an interpretation with 3 states using ideas from modular arithmetic, similar to .   "
},
{
  "id": "activity-17",
  "level": "2",
  "url": "DFA.html#activity-17",
  "type": "Activity",
  "number": "2.2.4",
  "title": "",
  "body": "  Make a DFA that is equivalent to the marble-rolling toy of . This will take some thought. I did it with 16 states originally, and 13 of them turned out to be accessible.   "
},
{
  "id": "act-extended-trans-induction",
  "level": "2",
  "url": "DFA.html#act-extended-trans-induction",
  "type": "Activity",
  "number": "2.2.5",
  "title": "",
  "body": "  Recall that if is an automaton, we defined the extended transition function inductively for a word (where ) by However, we think informally about as describing what happens along a path with a certain string of labels. So it should not matter how we break the input string in the definition of . That is, we should be able to use any factorization , not just one with . Use induction on to prove that .    Use the induction framework elaborated in , particularly in .   "
},
{
  "id": "activity-19",
  "level": "2",
  "url": "DFA.html#activity-19",
  "type": "Activity",
  "number": "2.2.6",
  "title": "",
  "body": "  Show that for any state , string , and input symbol , .    Use the result of .   "
},
{
  "id": "activity-20",
  "level": "2",
  "url": "DFA.html#activity-20",
  "type": "Activity",
  "number": "2.2.7",
  "title": "",
  "body": "  Give DFAs accepting the following languages over the alphabet :   The set of all strings such that each block of 5 consecutive symbols contains at least two 0s  The set of all strings whose third symbol from the right is a 1  The set of strings that either begin or end (or both) with 01  The set of strings such that the number of 0s is divisible by 5 and the number of 1s is divisible by 3    "
},
{
  "id": "activity-21",
  "level": "2",
  "url": "DFA.html#activity-21",
  "type": "Activity",
  "number": "2.2.8",
  "title": "",
  "body": "  Let be a DFA and a particular state of , such that for all . Show by induction on that for all input words .   "
},
{
  "id": "activity-22",
  "level": "2",
  "url": "DFA.html#activity-22",
  "type": "Activity",
  "number": "2.2.9",
  "title": "",
  "body": "  Let be a DFA and a particular state of , such that for all .    Show by induction on that for all , , where is the string consisting of  s.    Show that either or .     "
},
{
  "id": "activity-23",
  "level": "2",
  "url": "DFA.html#activity-23",
  "type": "Activity",
  "number": "2.2.10",
  "title": "",
  "body": "  Let be a DFA, and suppose that for all we have .    Show that for all we have .    Show that if is a nonempty string in , then for all , then , the -fold concatenation of , is also in .     "
},
{
  "id": "activity-24",
  "level": "2",
  "url": "DFA.html#activity-24",
  "type": "Activity",
  "number": "2.2.11",
  "title": "",
  "body": "  Consider the DFA with the following transition table:      0  1              Informally describe the language accepted by this DFA, and prove by induction on the length of the input that your description is correct.    When setting up the inductive hypothesis, it is wise to make a statement about what inputs get you to each state, not just what inputs get you to the accepting state.   "
}
]

var ptx_lunr_idx = lunr(function () {
  this.ref('id')
  this.field('title')
  this.field('body')

  ptx_lunr_docs.forEach(function (doc) {
    this.add(doc)
  }, this)
})
