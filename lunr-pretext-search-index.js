var ptx_lunr_search_style = "textbook";
var ptx_lunr_docs = [
{
  "id": "colophon-1",
  "level": "1",
  "url": "colophon-1.html",
  "type": "Colophon",
  "number": "",
  "title": "Colophon",
  "body": "  https:\/\/example.org   copyright  "
},
{
  "id": "sec-proofs",
  "level": "1",
  "url": "sec-proofs.html",
  "type": "Section",
  "number": "1.1",
  "title": "Proofs",
  "body": " Proofs          Class Activities      Negate the following statement:   Choose the correct statement:   Mike is not tall, or Karen is not tall    Mike is tall, or Karen is tall    Mike is not tall, and Karen is not tall    Mike is tall, and Karen is tall     Let be the statement Let be the statement First, translate the statement into formal logic. In this statement, is true, and is true. Therefore, the correct answer is  and  , or . Now, negate the statement.  Thus, the answer is Recall what and represent:  From , we get           Buttercup knows whether or not Westley is lying. She promises that if Westley is lying, she will give you a cookie. Buttercup always keeps her promises.  Suppose she does not give you a cookie; what can you conclude?    Westley is lying.    Westley is not lying.    Not enough information to determine.    Suppose she gives you a cookie; what can you conclude?    Westley is lying.    Westley is not lying.    Not enough information to determine.                        Negate the following statement:     Write the statement in formal logic:               Negate the logic:               Rewrite the negated logic in English   Mary does not fail her classes or she cannot graduate    Mary does not fail her classes and she cannot graduate    Mary does not fail her classes and she can graduate    Mary fails her classes and she can graduate       In this statement, if is true, then is false. This is an relationship. Thus, the answer is Now, negate the statement. In order to negate this statement, first translate it into an statement to get rid of the operator.   Thus, the answer is Recall what and represent:  From , we get           Negate the following statement.     Choose the correct statement:                  First, translate the statement into formal logic. In this statement, can be true, xor can be true, or neither can be true. The key here is that while either one can succeed, there is no guarantee of success. The expression is then equal to Now, negate the statement.   The answer is then As an extra exercise, what would this statement translate to in English?          Which of the following are equivalent to ? Select all that apply.            Which of the following are equivalent to the contrapositive of the logical expression ? Select all that apply.            We say a set is finite if there is a nonnegative integer such that the proposition is true. If is a finite set, then denotes the size of , the number of its elements.  A one-to-one correspondence or bijection is a function that can be reversed. Given a function , you can tell that is a bijection if it pairs each input (argument) to a unique output (value).    Let be a finite set. How many functions are there with domain and codomain ?  Try listing all possibilities for . A pattern should emerge. Once you think you see it, try to explain why that is the answer. The lists you made for the small examples should help you see the general case.   Establish a one-to-one correspondence (i.e., a bijection) between the set of functions and the power set .  The inputs of your bijection could be the functions and the outputs the elements of the set .   Define a function by the equation . We will show that is a bijection. Bijections are functions with two properties:   If then (no overlap\/collision; at most one inbound arrow for each codomain element)  For each in the codomain, there is in the domain such that (every codomain element covered ; at least one inbound arrow for each codomain element)   Suppose that and are distinct functions . We need to show that . The first is the subset of on which takes the value . The second is the same set, but for . Since , there is some where . Since the only possible values of these functions are and , it follows that exactly one of and is equal to . Hence is a member of or , but not both. This shows that has the first property of a bijection.  To obtain the second, let us choose an arbitrary element . This is just a subset of . We must show that there exists a function such that . We may of course define and then we see at once that has the desired property. We have now shown that has both properties of a bijection.   Conclude that , and identify the common value of these expressions. (Your answer will depend on .)  Since we have seen a bijection between these sets, they have the same size. We listed all the binary functions on variables; there are of them, so there must be subsets of as well. Observe these combine to say for every finite set .     "
},
{
  "id": "objectives-1",
  "level": "2",
  "url": "sec-proofs.html#objectives-1",
  "type": "Objectives",
  "number": "1.1",
  "title": "",
  "body": "      "
},
{
  "id": "activity-1",
  "level": "2",
  "url": "sec-proofs.html#activity-1",
  "type": "Activity",
  "number": "1.1.1",
  "title": "",
  "body": "   Negate the following statement:   Choose the correct statement:   Mike is not tall, or Karen is not tall    Mike is tall, or Karen is tall    Mike is not tall, and Karen is not tall    Mike is tall, and Karen is tall     Let be the statement Let be the statement First, translate the statement into formal logic. In this statement, is true, and is true. Therefore, the correct answer is  and  , or . Now, negate the statement.  Thus, the answer is Recall what and represent:  From , we get       "
},
{
  "id": "activity-2",
  "level": "2",
  "url": "sec-proofs.html#activity-2",
  "type": "Activity",
  "number": "1.1.2",
  "title": "",
  "body": "   Buttercup knows whether or not Westley is lying. She promises that if Westley is lying, she will give you a cookie. Buttercup always keeps her promises.  Suppose she does not give you a cookie; what can you conclude?    Westley is lying.    Westley is not lying.    Not enough information to determine.    Suppose she gives you a cookie; what can you conclude?    Westley is lying.    Westley is not lying.    Not enough information to determine.                    "
},
{
  "id": "activity-3",
  "level": "2",
  "url": "sec-proofs.html#activity-3",
  "type": "Activity",
  "number": "1.1.3",
  "title": "",
  "body": "   Negate the following statement:     Write the statement in formal logic:               Negate the logic:               Rewrite the negated logic in English   Mary does not fail her classes or she cannot graduate    Mary does not fail her classes and she cannot graduate    Mary does not fail her classes and she can graduate    Mary fails her classes and she can graduate       In this statement, if is true, then is false. This is an relationship. Thus, the answer is Now, negate the statement. In order to negate this statement, first translate it into an statement to get rid of the operator.   Thus, the answer is Recall what and represent:  From , we get       "
},
{
  "id": "activity-4",
  "level": "2",
  "url": "sec-proofs.html#activity-4",
  "type": "Activity",
  "number": "1.1.4",
  "title": "",
  "body": "   Negate the following statement.     Choose the correct statement:                  First, translate the statement into formal logic. In this statement, can be true, xor can be true, or neither can be true. The key here is that while either one can succeed, there is no guarantee of success. The expression is then equal to Now, negate the statement.   The answer is then As an extra exercise, what would this statement translate to in English?      "
},
{
  "id": "activity-5",
  "level": "2",
  "url": "sec-proofs.html#activity-5",
  "type": "Activity",
  "number": "1.1.5",
  "title": "",
  "body": "  Which of the following are equivalent to ? Select all that apply.         "
},
{
  "id": "activity-6",
  "level": "2",
  "url": "sec-proofs.html#activity-6",
  "type": "Activity",
  "number": "1.1.6",
  "title": "",
  "body": "  Which of the following are equivalent to the contrapositive of the logical expression ? Select all that apply.         "
},
{
  "id": "activity-7",
  "level": "2",
  "url": "sec-proofs.html#activity-7",
  "type": "Activity",
  "number": "1.1.7",
  "title": "",
  "body": "  We say a set is finite if there is a nonnegative integer such that the proposition is true. If is a finite set, then denotes the size of , the number of its elements.  A one-to-one correspondence or bijection is a function that can be reversed. Given a function , you can tell that is a bijection if it pairs each input (argument) to a unique output (value).    Let be a finite set. How many functions are there with domain and codomain ?  Try listing all possibilities for . A pattern should emerge. Once you think you see it, try to explain why that is the answer. The lists you made for the small examples should help you see the general case.   Establish a one-to-one correspondence (i.e., a bijection) between the set of functions and the power set .  The inputs of your bijection could be the functions and the outputs the elements of the set .   Define a function by the equation . We will show that is a bijection. Bijections are functions with two properties:   If then (no overlap\/collision; at most one inbound arrow for each codomain element)  For each in the codomain, there is in the domain such that (every codomain element covered ; at least one inbound arrow for each codomain element)   Suppose that and are distinct functions . We need to show that . The first is the subset of on which takes the value . The second is the same set, but for . Since , there is some where . Since the only possible values of these functions are and , it follows that exactly one of and is equal to . Hence is a member of or , but not both. This shows that has the first property of a bijection.  To obtain the second, let us choose an arbitrary element . This is just a subset of . We must show that there exists a function such that . We may of course define and then we see at once that has the desired property. We have now shown that has both properties of a bijection.   Conclude that , and identify the common value of these expressions. (Your answer will depend on .)  Since we have seen a bijection between these sets, they have the same size. We listed all the binary functions on variables; there are of them, so there must be subsets of as well. Observe these combine to say for every finite set .   "
},
{
  "id": "sec-induction",
  "level": "1",
  "url": "sec-induction.html",
  "type": "Section",
  "number": "1.2",
  "title": "Induction",
  "body": " Induction      Let be a subset of the natural numbers satisfying  ; and  If , then .  Then .     We usually apply the induction theorem in a highly implicit way. It is only invoked by name in introductory texts like this one. We have a sequence of theorems we wish to prove by induction. Usually we are too lazy to speak this way and we say we are proving one theorem, but about every natural number instead of a specific one (or about trees of arbitrary height instead of trees of height ). Each theorem in our sequence has a hypothesis and a conclusion . Often all of the are the same, but it doesn't hurt anything to let them be different. It happens even more often that all of the are specializations of a statement about integers to a specific integer. What we do when we write a proof by induction is to apply the induction theorem to the set defined by , that is, the set of natural numbers (or e.g. tree heights) for which our theorem holds. If we can show the hypotheses of the induction theorem apply to the set , our proof is complete, because the conclusion of the induction theorem then entails that .  This is what I meant in class when I spoke of an argument machine . As stated above, none of this framework is ever explicitly mentioned in practice. In undergraduate books, it is considered enough to mention induction, prove a base case and an induction step or inductive case (two phrases for the same thing), and voilà! The proof is complete.  Thus, the induction framework consists of arranging your argument so that the sequences and are clear. We call the theorem the base case . This theorem could also be stated as .   The inductive case is always phrased as a conditional. If  is a natural number that is in , then  is also in . If you recall the definition of , you will see that this conditional is equivalent to . So, we usually formulate our induction step in the latter way. My induction hypothesis would be implies . From this hypothesis I would attempt to deduce the conclusion, implies .  As a final thought, I should tell you that in our real writing, we don't usually assign values like to specific predicates like divides . I have done so here to aid in my clear expression, but you should try to craft your argument without using phrases like:  now let  assume  the theorem is true for      Class activities    Show, using induction, that if is a natural number, then divides .   Here is the empty statement and is the statement divides . The empty statement is indistinguishable from the logical constant .    The base case is to show that satisfies the conclusion of the statement. But , so the base case is done.  The inductive case is always phrased as a conditional. If  is a natural number that is in , then  is also in . Let us prove this statement. We will use a direct proof, assuming the hypothesis ( divides ) and deducing the conclusion ( divides ).  Since divides , the definition of divisibility tells us there is such that Multiplying this equation by 4 and adding 3, we obtain Since , we have shown that and the induction step is complete, as is the proof.      Prove that for all natural numbers , divides . Use the induction framework.    The base case is just like before. The inductive step is to prove: if divides , it also divides .  Here are some helpful facts that you can use without proof. In a math class, we'd prove these as exercises as well, but here I'm hoping to provide enough math hints that you can focus more on the logical structure of the argument and less on the arithmetic.  If divides and divides , then divides .  is even is the same statement as divides .  If divides , then divides for all integers .  If divides and divides , then divides .        In this activity we deal with points in the -dimensional Euclidean space . Such a point is specified by an -tuple of coordinates , where each .  The unit cube in , or unit -cube , is the subset of defined by   Just as a 3-dimensional cube has 2-, 1-, and 0-dimensional faces (usually called faces, edges, and corners, respectively), the -cube has faces of all lower dimensions. We are interested in the corners.  The corners of are defined to be the points of , all of whose coordinates are either 0 or 1. For example, is a corner of .    Prove that has corners using the induction framework.      The Fibonacci numbers are defined by The sequence begins .    Consider a rectangular array of squares, and the problem of determining the number of ways it may be tiled by dominoes. Each domino must cover exactly 2 adjacent squares, without overlaps. So, one way is to use all parallel dominoes. If happens to be even, all horizontal dominoes will work as well.      Of course, other tilings are also possible.     You can probably draw all 13 tilings of the grid quite easily. It turns out that 13 is also the value of , the 7th Fibonacci number. This isn't a coincidence, as you're asked to show below.  Using the recurrence relation above and the induction framework, show that there are such tilings of the array by dominoes, for all .   Note. For , we say that there is one way to tile an empty array with no dominoes. There would be zero ways to do it with more dominoes, and zero ways to tile a nonempty array with no dominoes.   Consider the ways in which a tiling of a array can arise from a smaller tiling. Remember, you need to show that the number of -tilings is the sum of the number of -tilings and the number of -tilings.   If we look at the last column of an -tiling, it must be either a single vertical domino or the two ends of two horizontal ones. If the former, removing it yields an -tiling. If the latter, removing both dominoes yields an -tiling.   We will use the induction framework to prove the following claim: For each , the number of tilings of an grid by dominoes is equal to . Recall first the recurrence relation for the Fibonacci numbers: .  The base cases are:   There is 1 way to tile a grid by 0 dominoes. There is nothing to prove.    There is 1 way to tile a grid by 1 domino. Again, this is evident, and there is nothing to prove.     For the induction step, let us suppose that, for some , we already know that there are tilings of the grid and tilings of the grid. Consider, then, a tiling of the grid. The rightmost column of this tiling has to look like one of the figures below.           The two ways the last column of the tiling can look.   Now it is clear that each tiling that resembles the figure on the left is obtained from a unique tiling by adding a single vertical domino. Similarly, each tiling that resembles the figure on the right is obtained from a unique tiling by adding two horizontal dominoes. Since each tiling of the grid is obtained from exactly one smaller tiling, we have shown (writing for the number of tilings): . It follows at once that , since they obey the same recurrence relations.      What is wrong with the following argument?   (Alleged theorem)   All cars are blue.    It is enough to show that given a nonempty finite set of cars, all of them are the same color. Since mine is blue, the result will follow at once. Let us prove by induction that every nonempty finite set of cars is monochromatic. If the set has just one car, it is surely monochromatic. Now let us suppose, by way of induction, that for some positive integer it has already been shown that every set of cars is monochromatic.  Consider a set of cars. We may form sets , by deleting the th car from to form . Applying the induction hypothesis to each of the sets we see that each of these sets is monochromatic. But then is monochromatic as well, and the proof is complete.       "
},
{
  "id": "objectives-2",
  "level": "2",
  "url": "sec-induction.html#objectives-2",
  "type": "Objectives",
  "number": "1.2",
  "title": "",
  "body": ""
},
{
  "id": "thm-induction",
  "level": "2",
  "url": "sec-induction.html#thm-induction",
  "type": "Theorem",
  "number": "1.2.1",
  "title": "",
  "body": "  Let be a subset of the natural numbers satisfying  ; and  If , then .  Then .   "
},
{
  "id": "rem-induction-framework",
  "level": "2",
  "url": "sec-induction.html#rem-induction-framework",
  "type": "Remark",
  "number": "1.2.2",
  "title": "",
  "body": " We usually apply the induction theorem in a highly implicit way. It is only invoked by name in introductory texts like this one. We have a sequence of theorems we wish to prove by induction. Usually we are too lazy to speak this way and we say we are proving one theorem, but about every natural number instead of a specific one (or about trees of arbitrary height instead of trees of height ). Each theorem in our sequence has a hypothesis and a conclusion . Often all of the are the same, but it doesn't hurt anything to let them be different. It happens even more often that all of the are specializations of a statement about integers to a specific integer. What we do when we write a proof by induction is to apply the induction theorem to the set defined by , that is, the set of natural numbers (or e.g. tree heights) for which our theorem holds. If we can show the hypotheses of the induction theorem apply to the set , our proof is complete, because the conclusion of the induction theorem then entails that .  This is what I meant in class when I spoke of an argument machine . As stated above, none of this framework is ever explicitly mentioned in practice. In undergraduate books, it is considered enough to mention induction, prove a base case and an induction step or inductive case (two phrases for the same thing), and voilà! The proof is complete.  Thus, the induction framework consists of arranging your argument so that the sequences and are clear. We call the theorem the base case . This theorem could also be stated as .  "
},
{
  "id": "activity-8",
  "level": "2",
  "url": "sec-induction.html#activity-8",
  "type": "Activity",
  "number": "1.2.1",
  "title": "",
  "body": "  Show, using induction, that if is a natural number, then divides .   Here is the empty statement and is the statement divides . The empty statement is indistinguishable from the logical constant .    The base case is to show that satisfies the conclusion of the statement. But , so the base case is done.  The inductive case is always phrased as a conditional. If  is a natural number that is in , then  is also in . Let us prove this statement. We will use a direct proof, assuming the hypothesis ( divides ) and deducing the conclusion ( divides ).  Since divides , the definition of divisibility tells us there is such that Multiplying this equation by 4 and adding 3, we obtain Since , we have shown that and the induction step is complete, as is the proof.   "
},
{
  "id": "activity-9",
  "level": "2",
  "url": "sec-induction.html#activity-9",
  "type": "Activity",
  "number": "1.2.2",
  "title": "",
  "body": "  Prove that for all natural numbers , divides . Use the induction framework.    The base case is just like before. The inductive step is to prove: if divides , it also divides .  Here are some helpful facts that you can use without proof. In a math class, we'd prove these as exercises as well, but here I'm hoping to provide enough math hints that you can focus more on the logical structure of the argument and less on the arithmetic.  If divides and divides , then divides .  is even is the same statement as divides .  If divides , then divides for all integers .  If divides and divides , then divides .     "
},
{
  "id": "subsec-unit-cube",
  "level": "2",
  "url": "sec-induction.html#subsec-unit-cube",
  "type": "Activity",
  "number": "1.2.3",
  "title": "",
  "body": "  In this activity we deal with points in the -dimensional Euclidean space . Such a point is specified by an -tuple of coordinates , where each .  The unit cube in , or unit -cube , is the subset of defined by   Just as a 3-dimensional cube has 2-, 1-, and 0-dimensional faces (usually called faces, edges, and corners, respectively), the -cube has faces of all lower dimensions. We are interested in the corners.  The corners of are defined to be the points of , all of whose coordinates are either 0 or 1. For example, is a corner of .    Prove that has corners using the induction framework.   "
},
{
  "id": "activity-11",
  "level": "2",
  "url": "sec-induction.html#activity-11",
  "type": "Activity",
  "number": "1.2.4",
  "title": "",
  "body": "  The Fibonacci numbers are defined by The sequence begins .    Consider a rectangular array of squares, and the problem of determining the number of ways it may be tiled by dominoes. Each domino must cover exactly 2 adjacent squares, without overlaps. So, one way is to use all parallel dominoes. If happens to be even, all horizontal dominoes will work as well.      Of course, other tilings are also possible.     You can probably draw all 13 tilings of the grid quite easily. It turns out that 13 is also the value of , the 7th Fibonacci number. This isn't a coincidence, as you're asked to show below.  Using the recurrence relation above and the induction framework, show that there are such tilings of the array by dominoes, for all .   Note. For , we say that there is one way to tile an empty array with no dominoes. There would be zero ways to do it with more dominoes, and zero ways to tile a nonempty array with no dominoes.   Consider the ways in which a tiling of a array can arise from a smaller tiling. Remember, you need to show that the number of -tilings is the sum of the number of -tilings and the number of -tilings.   If we look at the last column of an -tiling, it must be either a single vertical domino or the two ends of two horizontal ones. If the former, removing it yields an -tiling. If the latter, removing both dominoes yields an -tiling.   We will use the induction framework to prove the following claim: For each , the number of tilings of an grid by dominoes is equal to . Recall first the recurrence relation for the Fibonacci numbers: .  The base cases are:   There is 1 way to tile a grid by 0 dominoes. There is nothing to prove.    There is 1 way to tile a grid by 1 domino. Again, this is evident, and there is nothing to prove.     For the induction step, let us suppose that, for some , we already know that there are tilings of the grid and tilings of the grid. Consider, then, a tiling of the grid. The rightmost column of this tiling has to look like one of the figures below.           The two ways the last column of the tiling can look.   Now it is clear that each tiling that resembles the figure on the left is obtained from a unique tiling by adding a single vertical domino. Similarly, each tiling that resembles the figure on the right is obtained from a unique tiling by adding two horizontal dominoes. Since each tiling of the grid is obtained from exactly one smaller tiling, we have shown (writing for the number of tilings): . It follows at once that , since they obey the same recurrence relations.   "
},
{
  "id": "activity-12",
  "level": "2",
  "url": "sec-induction.html#activity-12",
  "type": "Activity",
  "number": "1.2.5",
  "title": "",
  "body": "  What is wrong with the following argument?   (Alleged theorem)   All cars are blue.    It is enough to show that given a nonempty finite set of cars, all of them are the same color. Since mine is blue, the result will follow at once. Let us prove by induction that every nonempty finite set of cars is monochromatic. If the set has just one car, it is surely monochromatic. Now let us suppose, by way of induction, that for some positive integer it has already been shown that every set of cars is monochromatic.  Consider a set of cars. We may form sets , by deleting the th car from to form . Applying the induction hypothesis to each of the sets we see that each of these sets is monochromatic. But then is monochromatic as well, and the proof is complete.     "
},
{
  "id": "DFA-intro",
  "level": "1",
  "url": "DFA-intro.html",
  "type": "Section",
  "number": "2.1",
  "title": "Examples of finite state automata",
  "body": " Examples of finite state automata    Learn stuff     The bank store customer model  Some stuff    The marble-rolling toy    (This example is due to HMU.) Consider the marble-rolling toy pictured below. A marble enters at either or . The path taken by the marble is determined by three levers. Lever 1 is immediately beneath A. If it points left, the marble rolls left and exits through output C. If Lever 1 points right, the marble rolls right and lands on Lever 2 (between A and B). If Lever 2 points left, the marble rolls left and exits through output C. If Lever 2 points rights, the marble rolls right and exits through output D. Finally, Lever 3 is beneath input B. If it points left, we go to Lever 2; otherwise, to output D.  Let us say that a word is accepted if, when we begin in the pictured starting configuration, rolling a marble for each symbol, the final marble exits at .   A marble-rolling toy with two input chutes labeled A and B, and two output chutes labeled C and D. The path taken by the marble is determined by three levers. Lever 1 is immediately beneath A. If it points left, the marble rolls left and exits through output C. If Lever 1 points right, the marble rolls right and lands on Lever 2 (between A and B). If Lever 2 points left, the marble rolls left and exits through output C. If Lever 2 points right, the marble rolls right and exits through output D. Finally, Lever 3 is beneath input B. If it points left, we go to Lever 2; otherwise, to output D.      Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?   Find all the words on of length at most accepted by the marble-rolling toy, assuming that a word is accepted if the last marble exits at D.   (empty word)                                   Can you describe the language accepted by the toy?       "
},
{
  "id": "objectives-3",
  "level": "2",
  "url": "DFA-intro.html#objectives-3",
  "type": "Objectives",
  "number": "2.1",
  "title": "",
  "body": "  Learn stuff   "
},
{
  "id": "act-marble-toy",
  "level": "2",
  "url": "DFA-intro.html#act-marble-toy",
  "type": "Activity",
  "number": "2.1.1",
  "title": "",
  "body": "  (This example is due to HMU.) Consider the marble-rolling toy pictured below. A marble enters at either or . The path taken by the marble is determined by three levers. Lever 1 is immediately beneath A. If it points left, the marble rolls left and exits through output C. If Lever 1 points right, the marble rolls right and lands on Lever 2 (between A and B). If Lever 2 points left, the marble rolls left and exits through output C. If Lever 2 points rights, the marble rolls right and exits through output D. Finally, Lever 3 is beneath input B. If it points left, we go to Lever 2; otherwise, to output D.  Let us say that a word is accepted if, when we begin in the pictured starting configuration, rolling a marble for each symbol, the final marble exits at .   A marble-rolling toy with two input chutes labeled A and B, and two output chutes labeled C and D. The path taken by the marble is determined by three levers. Lever 1 is immediately beneath A. If it points left, the marble rolls left and exits through output C. If Lever 1 points right, the marble rolls right and lands on Lever 2 (between A and B). If Lever 2 points left, the marble rolls left and exits through output C. If Lever 2 points right, the marble rolls right and exits through output D. Finally, Lever 3 is beneath input B. If it points left, we go to Lever 2; otherwise, to output D.      Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?  Does the toy accept ?   Find all the words on of length at most accepted by the marble-rolling toy, assuming that a word is accepted if the last marble exits at D.   (empty word)                                   Can you describe the language accepted by the toy?     "
},
{
  "id": "DFA",
  "level": "1",
  "url": "DFA.html",
  "type": "Section",
  "number": "2.2",
  "title": "Deterministic finite automata",
  "body": " Deterministic finite automata          Class Activities  Now you know that to specify a DFA, it is really enough to give the transition function . A transition table or transition diagram has enough information to specify the set of states, the set of symbols, the start state, and the set of accepting states.  In the reading, you have seen how a DFA is like a very simple computer, modeled by walks on a directed graph. Each move in the walk is determined by the transition function of the DFA as we consume the characters in the input string one by one.    For each pictured DFA, give a simple description of the language it accepts. Get the instructor to check before moving on.              Designing DFA  When designing a DFA or other automaton, it can be helpful to imagine yourself as the DFA and consider your cognition as you read the input word one symbol at a time. What must you remember about the string? How do you perform the DFA's task? It helps when doing this to remember that the word might be very long, so long you can't remember it all at once. You also don't know when the string will end, so you must always be ready with the answer.  Suppose that the alphabet is and we wish to accept all words with an odd number of 1s. If you start going through a long input string of 0s and 1s, one symbol at a time, do you need to see the whole string? Do you need to remember any of it? No, you simply keep track of whether the number of 1s you have seen so far is even or odd.  This gives a clue to the design of the DFA. There are two states and , corresponding to having seen an even or odd number of 1s so far. We begin in state , since at the beginning, we haven't seen any symbols and in particular have seen no 1s. Now the transitions should be clear: all transitions labeled with are self-loops, since the number of 1s does not change. Similarly, each transition labeled with changes state, because whenever we read a 1, the number of 1s seen so far changes parity.  There is just one accepting state, state , because that is the condition for having seen an odd number of 1s so far. If we are in state when the input ends, we win; otherwise, our string must be rejected.     Give diagrams or tables for DFA accepting the following languages over the alphabet . Make sure your answers include at least one table and one diagram. Get the instructor to check before you go on.   The set of all strings with 011 as a substring.   Words on with an odd number of b    Words on that start with 000    Words on that end in 11   The set of all strings with three consecutive 0s (not necessarily at the end)        Give DFA accepting the following languages over the alphabet :   The set of all strings beginning with a 1 such that, when is interpreted as a binary integer, it is a multiple of 3. For example, strings 11, 110, and 1111 are in the language, while 10, 100, and 111 are not.  The set of all such strings that, when interpreted in reverse as binary integers, are multiples of 3. Examples of strings in the language are 0, 00011, and 1001000. Observe there is no restriction on the leading digit in this part.      There is an interpretation with 3 states using ideas from modular arithmetic, similar to .      Make a DFA that is equivalent to the marble-rolling toy of . This will take some thought. I did it with 16 states originally, and 13 of them turned out to be accessible.      Recall that if is an automaton, we defined the extended transition function inductively for a word (where ) by However, we think informally about as describing what happens along a path with a certain string of labels. So it should not matter how we break the input string in the definition of . That is, we should be able to use any factorization , not just one with .      Use induction on to prove that .    Use the induction framework elaborated in , particularly in .    We will prove the theorem by induction on . The base case, which is , then looks like .  We compute . Here follows by the definition of concatenation, and follows by . This completes the proof that our theorem is true when .  For the inductive step, let us first clearly state the induction hypothesis. It is that, for some , we have , for all . Now let be the length of . It plays no role whatsoever in the proof, and really doesn't even need a name, but you might feel more comfortable seeing it in the cast list.  If is a symbol from , then has length . Let us compute: . Above, follows by substitution, by , by the induction hypothesis, by again, and by substitution again. This completes the inductive step.  Since every word in is either empty or obtained by concatenation of a letter to the end of a shorter word, the proof by induction is complete.    You should make sure you see and meditate on a solution to . It is an illustrative example for many similar induction proofs to follow.    Show that for any state , string , and input symbol , .    Use the result of .      Give DFA accepting the following languages over the alphabet :   The set of all strings such that each block of 5 consecutive symbols contains at least two 0s  The set of all strings whose third symbol from the right is a 1  The set of strings that either begin or end (or both) with 01  The set of strings such that the number of 0s is divisible by 5 and the number of 1s is divisible by 3        Let be a DFA and a particular state of , such that for all . Show by induction on that for all input words .      Let be a DFA and a particular state of , such that for all .    Show by induction on that for all , , where is the string consisting of  s.    Show that either or .       We use the exponential notation for self-concatenation of words as well as individual input symbols from . For example, if then .    Let be a DFA, and suppose that for all we have .    Show that for all we have .    Show that if is a nonempty string in , then for all , then , the -fold concatenation of , is also in .         Consider the DFA with the following transition table:      0  1              Informally describe the language accepted by this DFA, and prove by induction on the length of the input that your description is correct.    When setting up the inductive hypothesis, it is wise to make a statement about what inputs get you to each state, not just what inputs get you to the accepting state.     "
},
{
  "id": "objectives-4",
  "level": "2",
  "url": "DFA.html#objectives-4",
  "type": "Objectives",
  "number": "2.2",
  "title": "",
  "body": "      "
},
{
  "id": "activity-14",
  "level": "2",
  "url": "DFA.html#activity-14",
  "type": "Activity",
  "number": "2.2.1",
  "title": "",
  "body": "  For each pictured DFA, give a simple description of the language it accepts. Get the instructor to check before moving on.            "
},
{
  "id": "par-design-dfa",
  "level": "2",
  "url": "DFA.html#par-design-dfa",
  "type": "Remark",
  "number": "2.2.1",
  "title": "Designing DFA.",
  "body": " Designing DFA  When designing a DFA or other automaton, it can be helpful to imagine yourself as the DFA and consider your cognition as you read the input word one symbol at a time. What must you remember about the string? How do you perform the DFA's task? It helps when doing this to remember that the word might be very long, so long you can't remember it all at once. You also don't know when the string will end, so you must always be ready with the answer.  Suppose that the alphabet is and we wish to accept all words with an odd number of 1s. If you start going through a long input string of 0s and 1s, one symbol at a time, do you need to see the whole string? Do you need to remember any of it? No, you simply keep track of whether the number of 1s you have seen so far is even or odd.  This gives a clue to the design of the DFA. There are two states and , corresponding to having seen an even or odd number of 1s so far. We begin in state , since at the beginning, we haven't seen any symbols and in particular have seen no 1s. Now the transitions should be clear: all transitions labeled with are self-loops, since the number of 1s does not change. Similarly, each transition labeled with changes state, because whenever we read a 1, the number of 1s seen so far changes parity.  There is just one accepting state, state , because that is the condition for having seen an odd number of 1s so far. If we are in state when the input ends, we win; otherwise, our string must be rejected.  "
},
{
  "id": "activity-15",
  "level": "2",
  "url": "DFA.html#activity-15",
  "type": "Activity",
  "number": "2.2.2",
  "title": "",
  "body": "  Give diagrams or tables for DFA accepting the following languages over the alphabet . Make sure your answers include at least one table and one diagram. Get the instructor to check before you go on.   The set of all strings with 011 as a substring.   Words on with an odd number of b    Words on that start with 000    Words on that end in 11   The set of all strings with three consecutive 0s (not necessarily at the end)     "
},
{
  "id": "activity-16",
  "level": "2",
  "url": "DFA.html#activity-16",
  "type": "Activity",
  "number": "2.2.3",
  "title": "",
  "body": "  Give DFA accepting the following languages over the alphabet :   The set of all strings beginning with a 1 such that, when is interpreted as a binary integer, it is a multiple of 3. For example, strings 11, 110, and 1111 are in the language, while 10, 100, and 111 are not.  The set of all such strings that, when interpreted in reverse as binary integers, are multiples of 3. Examples of strings in the language are 0, 00011, and 1001000. Observe there is no restriction on the leading digit in this part.      There is an interpretation with 3 states using ideas from modular arithmetic, similar to .   "
},
{
  "id": "activity-17",
  "level": "2",
  "url": "DFA.html#activity-17",
  "type": "Activity",
  "number": "2.2.4",
  "title": "",
  "body": "  Make a DFA that is equivalent to the marble-rolling toy of . This will take some thought. I did it with 16 states originally, and 13 of them turned out to be accessible.   "
},
{
  "id": "def-deltahat",
  "level": "2",
  "url": "DFA.html#def-deltahat",
  "type": "Definition",
  "number": "2.2.2",
  "title": "",
  "body": "  Recall that if is an automaton, we defined the extended transition function inductively for a word (where ) by However, we think informally about as describing what happens along a path with a certain string of labels. So it should not matter how we break the input string in the definition of . That is, we should be able to use any factorization , not just one with .   "
},
{
  "id": "act-extended-trans-induction",
  "level": "2",
  "url": "DFA.html#act-extended-trans-induction",
  "type": "Activity",
  "number": "2.2.5",
  "title": "",
  "body": "  Use induction on to prove that .    Use the induction framework elaborated in , particularly in .    We will prove the theorem by induction on . The base case, which is , then looks like .  We compute . Here follows by the definition of concatenation, and follows by . This completes the proof that our theorem is true when .  For the inductive step, let us first clearly state the induction hypothesis. It is that, for some , we have , for all . Now let be the length of . It plays no role whatsoever in the proof, and really doesn't even need a name, but you might feel more comfortable seeing it in the cast list.  If is a symbol from , then has length . Let us compute: . Above, follows by substitution, by , by the induction hypothesis, by again, and by substitution again. This completes the inductive step.  Since every word in is either empty or obtained by concatenation of a letter to the end of a shorter word, the proof by induction is complete.   "
},
{
  "id": "activity-19",
  "level": "2",
  "url": "DFA.html#activity-19",
  "type": "Activity",
  "number": "2.2.6",
  "title": "",
  "body": "  Show that for any state , string , and input symbol , .    Use the result of .   "
},
{
  "id": "activity-20",
  "level": "2",
  "url": "DFA.html#activity-20",
  "type": "Activity",
  "number": "2.2.7",
  "title": "",
  "body": "  Give DFA accepting the following languages over the alphabet :   The set of all strings such that each block of 5 consecutive symbols contains at least two 0s  The set of all strings whose third symbol from the right is a 1  The set of strings that either begin or end (or both) with 01  The set of strings such that the number of 0s is divisible by 5 and the number of 1s is divisible by 3     "
},
{
  "id": "activity-21",
  "level": "2",
  "url": "DFA.html#activity-21",
  "type": "Activity",
  "number": "2.2.8",
  "title": "",
  "body": "  Let be a DFA and a particular state of , such that for all . Show by induction on that for all input words .   "
},
{
  "id": "activity-22",
  "level": "2",
  "url": "DFA.html#activity-22",
  "type": "Activity",
  "number": "2.2.9",
  "title": "",
  "body": "  Let be a DFA and a particular state of , such that for all .    Show by induction on that for all , , where is the string consisting of  s.    Show that either or .      "
},
{
  "id": "activity-23",
  "level": "2",
  "url": "DFA.html#activity-23",
  "type": "Activity",
  "number": "2.2.10",
  "title": "",
  "body": "  Let be a DFA, and suppose that for all we have .    Show that for all we have .    Show that if is a nonempty string in , then for all , then , the -fold concatenation of , is also in .      "
},
{
  "id": "activity-24",
  "level": "2",
  "url": "DFA.html#activity-24",
  "type": "Activity",
  "number": "2.2.11",
  "title": "",
  "body": "  Consider the DFA with the following transition table:      0  1              Informally describe the language accepted by this DFA, and prove by induction on the length of the input that your description is correct.    When setting up the inductive hypothesis, it is wise to make a statement about what inputs get you to each state, not just what inputs get you to the accepting state.   "
},
{
  "id": "NFA",
  "level": "1",
  "url": "NFA.html",
  "type": "Section",
  "number": "2.3",
  "title": "Nondeterministic finite automata",
  "body": " Nondeterministic finite automata   Introduction  In this section we have learned that NFA are much like DFA, but with more flexibility about the transitions. Recall that DFA are required to have a transition function with the signature . The definition of function means that there is thus exactly one outbound transition for each symbol and state .  With an NFA, this restriction is removed. A given state and symbol may yield 0, 1, or many outbound transitions. When there are 0, the computation can go no further, but when there are many, the automaton follows them all to their ends, by the mechanism of the redesigned transition function.  The transition function for NFA has a different signature. It is a function , where as before the exponentiated set is a power set. The meaning is simple: the value of is the set of states that can be reached from by following edges labeled . That's it!    Consider the following NFA:   An NFA that accepts all words ending in .      Evidently it accepts all words ending in . Give its formal components , , , , and .    The first four are , and is given by the table below.     0  1                   Notice how the table looks quite similar to those of . The only difference is that the function values are sets of states rather than individual states.    We defined the language of a DFA using the extended transition function (defined in ) as follows: , where is the start state of and is the set of accepting states. In order to define such a thing for NFA, we will probably need such an extended version of its transition function. This is also provided for us.  We defined the extended transition function as follows.    The extended transition function of an NFA is defined as follows. For any state and word ,     To interpret this we must know what the states , are. These are all the states we can reach by following the symbols in the prefix from the state . Remember, this is a recursive\/inductive definition, so we learn how to do an -symbol word from how to do an -symbol one. The second case in the definition says, follow the -transitions from every state , , , and the states you get in this way are all members of .   Let us compute using the inductive definition. It is not so easy to do the computation in the intuitive way, starting with the long string and working down to the empty string. The reason is simple: we don't know the ! But, we know from experience by now that we will end up evaluating for every prefix of . It will make our job simpler if we start with and work up from there.     , by definition. Since we can only reach the single state  so far , it is the only for the next step.     . Here there is only one from above and only one symbol, so the union is just the set . These are the for the next step.     . Here there are two states and , so two things in the union, but one of them is empty and we get nothing new yet.     This time, both things in the union are nonempty.             Later we will see that this means the word is accepted by this machine, because contains a state of .   Equipped with the extended transition function, we can define the language of an NFA.    If is our NFA, we define .     Let us prove that , the NFA of , accepts the language . That is, we wish to prove that where . Make sure you see why the defining property from becomes with our choice of .  We will use induction, but of the mutual variety. Here are the three statements we will prove by induction:   contains for every word .    contains if and only if ends in .    contains if and only if ends in .   Observe before continuing that only statement is really required by the theorem, but to make the induction go, we need to assume something about the other states too. This is typical of inductive proofs for DFA and NFA.  The induction begins with a base case, . We verify the three statements. All are obvious, since doesn't end in anything and by .  Next let us proceed to the inductive step. Consider a word (remember that and ). Then the length of is one more than the length of . In symbols, . We will assume that all three statements are true of the shorter word , and deduce them for the longer word .  To see that statement 1 holds for , we observe that by the induction hypothesis, . Since or , and there are loop transitions from labeled with both and , we see that , as required.  For statement 2, we need to prove both directions of the if and only if statement. It is a bit confusing if you have not seen it before. We say if and only if when we wish to assert simultaneously that and . The forward implication is , which confusingly is the only if part of the proof. The reverse implication is , which is the if part. In this case, the forward implication is and the reverse implication is .  To prove the forward implication, we observe that only has a transition to , and that transition is labeled . So the last letter of must be . For the reverse implication, suppose that ends in . Because we have assumed statement 1 for the prefix , we know that . Because there is a transition from to labeled , it follows that , which is what we wanted to prove.  The proof of statement 3 is left as an exercise.     The subset construction  Recall that there are a few differences between DFA and NFA:   DFA must have exactly one outbound transition from each state with each symbol, but NFA may have zero, one, or many such transitions.    The transition function for DFA looks like , but for NFA, it looks like .     It may seem that NFA are more powerful than DFA, but if you think back, we've given DFA to recognize every language we've seen an NFA for. The NFA are sometimes easier to read, very often easier to write, and in nice cases they are smaller than the DFA. But, as we'll see below, they aren't more powerful.    Let be an NFA. Then is regular, that is, there is a DFA such that .     For the proof of , see the proof of Theorem 2.11 in HMU.    Pseudo-NFA  In this section we introduce the concept of a pseudo-NFA , which is a machine that is almost an NFA, but not quite. The difference is that a pseudo-NFA may have more than one start state. This is not allowed for NFA according to HMU, but it is allowed for pseudo-NFA.  We introduce pseudo-NFA in part to show that they are just as sensible as NFA (indeed some authors only consider pseudo-NFA). In particular, we show in that the subset construction may be applied to a pseudo-NFA to produce a DFA that accepts the same language. This means that, to show a language is regular, it is enough to give a pseudo-NFA that accepts it. It also means that even pseudo-NFA are still not more computationally powerful than DFA.    A pseudo-NFA is a 5-tuple , where , , and are the same as for an NFA, but is a set of start states, and is a function .    We can extend the definition of to pseudo-NFA in a nice way. We need to be able to cope with a whole set of start states. The idea of is that it gives the set of possible next positions . If is a set of states, we can define capturing this idea. If we apply it to a proper NFA rather than a pseudo-NFA, we obtain almost the same function as before, except that it operates on singleton sets rather than individual states.    Let be a pseudo-NFA. Then       Let be a pseudo-NFA. Then .      If is an NFA, then the two definitions of are equivalent.      Let be a pseudo-NFA. Then there is a DFA such that .     The proof is the same as that of , except that we use the extended transition function defined in rather than the one defined in . The proof is left as an exercise.   The pseudo-NFA are convenient for proving results like the following.    If and are regular languages, then so is .     Since and are regular, there are DFA and such that and . We will construct a DFA such that . Let the state sets and transition functions of and be , and , , respectively. Without loss of generality, we may assume that and are disjoint. If they are not, we can rename the states of one of them.  The state set of will be the union of the states of and . Both the start states of and will be start states of . The accepting states of will be the union of the accepting states of and . The transition function of will be defined by   First, we observe that . To see this, first note that and . Therefore . To see the reverse inclusion, let . Then or . This shows that the , as required.  It is evident that so constructed is a pseudo-NFA. By , there is a DFA such that . But , so we are done.     Class Activities    Design NFA to recognize the following sets of keywords. Draw pictures on the whiteboard.    , , and . Assume the alphabet is .     , , and .     , , and . Assume the alphabet is .         Convert each of your NFA from to a DFA using the subset construction. Draw pictures on the whiteboard.      NFA with -transitions  In this section we introduce a new kind of NFA, which is allowed to have -transitions. These are transitions that can be taken without consuming any input. The purpose of such transitions is to allow the machine to jump from one place to another regardless of what symbol is next in the input. This is useful for making the machine smaller and easier to read. Like nondeterminism itself, -transitions do not increase the computational power of the machine.  In our transition diagrams, all we need to do is add a new kind of arrow, labeled with . In the transition tables, we write a new column for and specify all -transitions in that column.   Consider the -NFA shown below.   An NFA with -transitions.      This NFA accepts the language of possibly signed decimal numbers, including integers and numbers with a decimal point. The numbers don't have to have a sign, so there is an -transition from to . Similarly, it is cleaner to have an -transition from to to end the input than another transition with the same label.  The transition table for this machine is shown below.                                                             We need a formal mechanism to describe the acceptance of words by the -NFA. The idea is that the machine can take any number of -transitions whenever they are allowed, possibly in sequence, before it must read the next symbol of the input. This is captured by the definition of -closure below.    Let be a state in an -NFA. The -closure of , written , is a set of states in the NFA defined inductively as follows.   The state is in .    If state is in , and there is an -transition from to , then is in .       The -closure of a set of states is needed in order that we may define the extended transition function of a -NFA. The definition follows.    Let be an -NFA. Then the extended transition function of , written , is a function defined as follows.    for each state .     is defined as follows. First let be the members of the set . Then let be the members of the set . Then we define to be the set .       Like ordinary and pseudo-NFA, -NFA can be converted to DFA using a jazzed-up subset construction. The idea is to incorporate -closure into construction. The details may be found in HMU section 2.5.5.    Consider the following -NFA.                                  Compute the -closure of each state.    Give all the strings of length 3 or less computed by the automaton.         A relevant video  It probably doesn't belong here, but let's put it here anyway. I intended to show this video in class after we practiced the subset construction, but there wasn't time.   Professor Brailsford explains the Chomsky hierarchy.     "
},
{
  "id": "p-142",
  "level": "2",
  "url": "NFA.html#p-142",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "function "
},
{
  "id": "activity-25",
  "level": "2",
  "url": "NFA.html#activity-25",
  "type": "Activity",
  "number": "2.3.1",
  "title": "",
  "body": "  Consider the following NFA:   An NFA that accepts all words ending in .      Evidently it accepts all words ending in . Give its formal components , , , , and .    The first four are , and is given by the table below.     0  1                   Notice how the table looks quite similar to those of . The only difference is that the function values are sets of states rather than individual states.   "
},
{
  "id": "def-nfa-deltahat",
  "level": "2",
  "url": "NFA.html#def-nfa-deltahat",
  "type": "Definition",
  "number": "2.3.2",
  "title": "",
  "body": "  The extended transition function of an NFA is defined as follows. For any state and word ,    "
},
{
  "id": "example-1",
  "level": "2",
  "url": "NFA.html#example-1",
  "type": "Example",
  "number": "2.3.3",
  "title": "",
  "body": " Let us compute using the inductive definition. It is not so easy to do the computation in the intuitive way, starting with the long string and working down to the empty string. The reason is simple: we don't know the ! But, we know from experience by now that we will end up evaluating for every prefix of . It will make our job simpler if we start with and work up from there.     , by definition. Since we can only reach the single state  so far , it is the only for the next step.     . Here there is only one from above and only one symbol, so the union is just the set . These are the for the next step.     . Here there are two states and , so two things in the union, but one of them is empty and we get nothing new yet.     This time, both things in the union are nonempty.             Later we will see that this means the word is accepted by this machine, because contains a state of .  "
},
{
  "id": "def-nfa-language",
  "level": "2",
  "url": "NFA.html#def-nfa-language",
  "type": "Definition",
  "number": "2.3.4",
  "title": "",
  "body": "  If is our NFA, we define .   "
},
{
  "id": "example-2",
  "level": "2",
  "url": "NFA.html#example-2",
  "type": "Example",
  "number": "2.3.5",
  "title": "",
  "body": " Let us prove that , the NFA of , accepts the language . That is, we wish to prove that where . Make sure you see why the defining property from becomes with our choice of .  We will use induction, but of the mutual variety. Here are the three statements we will prove by induction:   contains for every word .    contains if and only if ends in .    contains if and only if ends in .   Observe before continuing that only statement is really required by the theorem, but to make the induction go, we need to assume something about the other states too. This is typical of inductive proofs for DFA and NFA.  The induction begins with a base case, . We verify the three statements. All are obvious, since doesn't end in anything and by .  Next let us proceed to the inductive step. Consider a word (remember that and ). Then the length of is one more than the length of . In symbols, . We will assume that all three statements are true of the shorter word , and deduce them for the longer word .  To see that statement 1 holds for , we observe that by the induction hypothesis, . Since or , and there are loop transitions from labeled with both and , we see that , as required.  For statement 2, we need to prove both directions of the if and only if statement. It is a bit confusing if you have not seen it before. We say if and only if when we wish to assert simultaneously that and . The forward implication is , which confusingly is the only if part of the proof. The reverse implication is , which is the if part. In this case, the forward implication is and the reverse implication is .  To prove the forward implication, we observe that only has a transition to , and that transition is labeled . So the last letter of must be . For the reverse implication, suppose that ends in . Because we have assumed statement 1 for the prefix , we know that . Because there is a transition from to labeled , it follows that , which is what we wanted to prove.  The proof of statement 3 is left as an exercise.  "
},
{
  "id": "thm-dfa-nfa-equiv",
  "level": "2",
  "url": "NFA.html#thm-dfa-nfa-equiv",
  "type": "Theorem",
  "number": "2.3.6",
  "title": "",
  "body": "  Let be an NFA. Then is regular, that is, there is a DFA such that .    "
},
{
  "id": "p-179",
  "level": "2",
  "url": "NFA.html#p-179",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pseudo-NFA "
},
{
  "id": "def-pseudo-nfa",
  "level": "2",
  "url": "NFA.html#def-pseudo-nfa",
  "type": "Definition",
  "number": "2.3.7",
  "title": "",
  "body": "  A pseudo-NFA is a 5-tuple , where , , and are the same as for an NFA, but is a set of start states, and is a function .   "
},
{
  "id": "def-transition-function-pnfa",
  "level": "2",
  "url": "NFA.html#def-transition-function-pnfa",
  "type": "Definition",
  "number": "2.3.8",
  "title": "",
  "body": "  Let be a pseudo-NFA. Then    "
},
{
  "id": "def-language-pnfa",
  "level": "2",
  "url": "NFA.html#def-language-pnfa",
  "type": "Definition",
  "number": "2.3.9",
  "title": "",
  "body": "  Let be a pseudo-NFA. Then .   "
},
{
  "id": "lemma-1",
  "level": "2",
  "url": "NFA.html#lemma-1",
  "type": "Lemma",
  "number": "2.3.10",
  "title": "",
  "body": "  If is an NFA, then the two definitions of are equivalent.   "
},
{
  "id": "thm-pseudo-nfa-subset",
  "level": "2",
  "url": "NFA.html#thm-pseudo-nfa-subset",
  "type": "Theorem",
  "number": "2.3.11",
  "title": "",
  "body": "  Let be a pseudo-NFA. Then there is a DFA such that .   "
},
{
  "id": "proof-2",
  "level": "2",
  "url": "NFA.html#proof-2",
  "type": "Proof",
  "number": "2.3.3.1",
  "title": "",
  "body": " The proof is the same as that of , except that we use the extended transition function defined in rather than the one defined in . The proof is left as an exercise.  "
},
{
  "id": "thm-regular-closed-union",
  "level": "2",
  "url": "NFA.html#thm-regular-closed-union",
  "type": "Theorem",
  "number": "2.3.12",
  "title": "",
  "body": "  If and are regular languages, then so is .   "
},
{
  "id": "proof-3",
  "level": "2",
  "url": "NFA.html#proof-3",
  "type": "Proof",
  "number": "2.3.3.2",
  "title": "",
  "body": " Since and are regular, there are DFA and such that and . We will construct a DFA such that . Let the state sets and transition functions of and be , and , , respectively. Without loss of generality, we may assume that and are disjoint. If they are not, we can rename the states of one of them.  The state set of will be the union of the states of and . Both the start states of and will be start states of . The accepting states of will be the union of the accepting states of and . The transition function of will be defined by   First, we observe that . To see this, first note that and . Therefore . To see the reverse inclusion, let . Then or . This shows that the , as required.  It is evident that so constructed is a pseudo-NFA. By , there is a DFA such that . But , so we are done.  "
},
{
  "id": "act-design-nfa",
  "level": "2",
  "url": "NFA.html#act-design-nfa",
  "type": "Activity",
  "number": "2.3.2",
  "title": "",
  "body": "  Design NFA to recognize the following sets of keywords. Draw pictures on the whiteboard.    , , and . Assume the alphabet is .     , , and .     , , and . Assume the alphabet is .      "
},
{
  "id": "activity-27",
  "level": "2",
  "url": "NFA.html#activity-27",
  "type": "Activity",
  "number": "2.3.3",
  "title": "",
  "body": "  Convert each of your NFA from to a DFA using the subset construction. Draw pictures on the whiteboard.   "
},
{
  "id": "ex-eps-transitions-diagram",
  "level": "2",
  "url": "NFA.html#ex-eps-transitions-diagram",
  "type": "Example",
  "number": "2.3.13",
  "title": "",
  "body": " Consider the -NFA shown below.   An NFA with -transitions.      This NFA accepts the language of possibly signed decimal numbers, including integers and numbers with a decimal point. The numbers don't have to have a sign, so there is an -transition from to . Similarly, it is cleaner to have an -transition from to to end the input than another transition with the same label.  The transition table for this machine is shown below.                                                            "
},
{
  "id": "p-204",
  "level": "2",
  "url": "NFA.html#p-204",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "-closure "
},
{
  "id": "def-eps-closure",
  "level": "2",
  "url": "NFA.html#def-eps-closure",
  "type": "Definition",
  "number": "2.3.15",
  "title": "",
  "body": "  Let be a state in an -NFA. The -closure of , written , is a set of states in the NFA defined inductively as follows.   The state is in .    If state is in , and there is an -transition from to , then is in .      "
},
{
  "id": "def-eps-nfa-deltahat",
  "level": "2",
  "url": "NFA.html#def-eps-nfa-deltahat",
  "type": "Definition",
  "number": "2.3.16",
  "title": "",
  "body": "  Let be an -NFA. Then the extended transition function of , written , is a function defined as follows.    for each state .     is defined as follows. First let be the members of the set . Then let be the members of the set . Then we define to be the set .      "
},
{
  "id": "activity-28",
  "level": "2",
  "url": "NFA.html#activity-28",
  "type": "Activity",
  "number": "2.3.4",
  "title": "",
  "body": "  Consider the following -NFA.                                  Compute the -closure of each state.    Give all the strings of length 3 or less computed by the automaton.      "
},
{
  "id": "figure-4",
  "level": "2",
  "url": "NFA.html#figure-4",
  "type": "Figure",
  "number": "2.3.17",
  "title": "",
  "body": " Professor Brailsford explains the Chomsky hierarchy.   "
},
{
  "id": "regex",
  "level": "1",
  "url": "regex.html",
  "type": "Section",
  "number": "2.4",
  "title": "Regular expressions",
  "body": " Regular expressions   Regular expressions are yet another way of describing the class of regular languages. We build them up from simpler ones using operations. It is more algebraic in feel than the state diagrams and automata.  Regular expressions find wide use throughout computing in text matching applications. My standard zoo of examples includes the venerable UNIX\/Linux utilities grep , sed , and awk . These are all based on regular expressions. They are also provided in every modern code editor and IDE, usually with extensions that go beyond the regular languages. Regular expressions find their way into these tools because their algebraic representation makes them easy to manipulate and combine and type into a terminal.  Alumni of CSC-235 will perhaps recognize regular expressions from the homework we did involving flex and bison . It is typical for the lexing phase of a compiler to be implemented using regular expressions.  The regular expressions that IDEs or editors provide are typically extended in ways that make them strictly more powerful than NFAs. There are also usually quality-of-life extensions, like character classes, that make regular expressions easier to read and write without making them more expressive. Of course, these extended regular expressions cannot be implemented via conversion to DFA as is often suggested. They must be handled in other ways, which are inevitably slower (some of the extensions, while fast in typical use cases, have running time in the worst case).  See the article for an excellent and readable comparison of the two approaches and learn how you can earn a one million dollar prize.    Operators and examples  Regular expressions denote languages. For example, denotes the language whose words are strings of any number of followed by a or strings of any number of followed by a single . All the operators and rules for interpreting regular expressions are explained below and more exhaustively in HMU 3.1. The operators are listed below, in order of decreasing precedence, in . The description refers to languages, not regular expressions, but the operators and their meanings and notations will be the same.   Operators for languages    Union  The union of the languages and is written . It contains all the words that are in either or .    Concatenation  The concatenation of two languages consists of the words where matches and matches . Notice that only one such decomposition is required to exist: if it's possible to decompose this way, it is in . As you see, the concatenation operator is usually not represented by an explicit symbol, but by juxtaposition. We frequently use powers to stand for self-concatenation. So, would be the same as , and would be the same as , and so on. Using this convention, we have and for all languages .    Star  The star operator represents the set of words formed from zero or more concatenations of the language to which it is applied. For example, denotes the set of strings obtaining by pasting zero or more strings from together. Another way to say it is: where the powers represent self-concatenation.      Example 3.1 in HMU is worth consulting. For a given language , it is not always so obvious what is.   In the algebra of regular expressions, we use the same operators to combine simpler expressions. Each regular expression has a language that it represents . The language of a regular expression is denoted , just like for automata.    The definition is inductive. Let the alphabet of symbols be some set . Then   The constants and are regular expressions. We define and .    If , then is a regular expression and .    A variable, usually capitalized like , is a regular expression. Such a variable represents a whole language.    If and are regular expressions, then so is their union . The language it represents is .    If and are regular expressions, then so is their concatenation . The language it represents is .    If is a regular expression, then so is its star . The language it represents is .    Finally, if is a regular expression, then so is its parenthesization . The language it represents is .     It is typical to also include the unary plus operator for regular expressions, but it is not necessary. We define to be . This is the set of strings that can be formed by concatenating one or more strings from (not zero or more).  Note that it is very common to conflate a regular expression with the language it represents, especially when speaking. We should try to be clear and keep them separate at first.      Write regular expressions for each language.    The set of strings over containing at least one and one    One that works is .    The set of strings of s and s with no consecutive s.           NFA and regular expressions    Draw an NFA for each regular expression over the alphabet . Remember that star has the highest precedence (must be evaluated first) and union ( ) the lowest. These are not trick questions.                  Observe how your answers to correspond to the operators on regular expressions: star (closure, per HMU), concatenation, and union.    In this exercise, use -transitions as needed, but make sure your NFA have  a single start state with no incoming transitions  a single accept state with no outgoing transitions.                     Draw an NFA whose language is the same as the language matched by the regular expression. Don't try to do it all at once: Instead, proceed inductively, making simple NFA and then combining them as in .           Suppose you are given NFA and each having  a single start state with no incoming transitions  a single accept state with no outgoing transitions.  Explain how you would combine these into a new NFA satisfying . should also satisfy conditions 1 and 2 above. You are allowed to use -transitions and to respecify the start and accepting states.      Suppose you are given NFA and each having  a single start state with no incoming transitions  a single accept state with no outgoing transitions.  Explain how you would combine these into a new NFA satisfying . should also satisfy conditions 1 and 2 above. You are allowed to use -transitions and to respecify the start and accepting states.      Suppose you are given an NFA having  a single start state with no incoming transitions  a single accept state with no outgoing transitions.  Explain how you would use to build a new NFA satisfying . should also satisfy conditions 1 and 2 above. You are allowed to use -transitions and to respecify the start and accepting states.         Suppose we have an NFA with multiple accept states, some of which might have outgoing transitions. Explain how to use an -transition and a new accept state to convert it to an equivalent NFA with a single accept state and no outgoing transitions from the accept state.    Suppose we have a pseudo-NFA (multiple start states), some of which might have incoming transitions. Explain how to use an -transition and a new start state to convert it to an equivalent NFA with a single start state and no incoming transitions to the start state.         Use your answers to the previous activities to devise a proof that every regular expression can be simulated by an NFA. The definition of regular expression is inductive, so an inductive proof suggests itself.      Russ Cox, Regular expression matching can be simple and fast (but is slow in Java, Perl, PHP, Python, Ruby, etc.)    "
},
{
  "id": "list-regex-ops",
  "level": "2",
  "url": "regex.html#list-regex-ops",
  "type": "List",
  "number": "2.4.1",
  "title": "Operators for languages",
  "body": " Operators for languages    Union  The union of the languages and is written . It contains all the words that are in either or .    Concatenation  The concatenation of two languages consists of the words where matches and matches . Notice that only one such decomposition is required to exist: if it's possible to decompose this way, it is in . As you see, the concatenation operator is usually not represented by an explicit symbol, but by juxtaposition. We frequently use powers to stand for self-concatenation. So, would be the same as , and would be the same as , and so on. Using this convention, we have and for all languages .    Star  The star operator represents the set of words formed from zero or more concatenations of the language to which it is applied. For example, denotes the set of strings obtaining by pasting zero or more strings from together. Another way to say it is: where the powers represent self-concatenation.    "
},
{
  "id": "ex-kleene-star",
  "level": "2",
  "url": "regex.html#ex-kleene-star",
  "type": "Example",
  "number": "2.4.2",
  "title": "",
  "body": " Example 3.1 in HMU is worth consulting. For a given language , it is not always so obvious what is.  "
},
{
  "id": "p-228",
  "level": "2",
  "url": "regex.html#p-228",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "represents "
},
{
  "id": "def-regex",
  "level": "2",
  "url": "regex.html#def-regex",
  "type": "Definition",
  "number": "2.4.3",
  "title": "",
  "body": "  The definition is inductive. Let the alphabet of symbols be some set . Then   The constants and are regular expressions. We define and .    If , then is a regular expression and .    A variable, usually capitalized like , is a regular expression. Such a variable represents a whole language.    If and are regular expressions, then so is their union . The language it represents is .    If and are regular expressions, then so is their concatenation . The language it represents is .    If is a regular expression, then so is its star . The language it represents is .    Finally, if is a regular expression, then so is its parenthesization . The language it represents is .     It is typical to also include the unary plus operator for regular expressions, but it is not necessary. We define to be . This is the set of strings that can be formed by concatenating one or more strings from (not zero or more).  Note that it is very common to conflate a regular expression with the language it represents, especially when speaking. We should try to be clear and keep them separate at first.   "
},
{
  "id": "activity-29",
  "level": "2",
  "url": "regex.html#activity-29",
  "type": "Activity",
  "number": "2.4.1",
  "title": "",
  "body": "  Write regular expressions for each language.    The set of strings over containing at least one and one    One that works is .    The set of strings of s and s with no consecutive s.        "
},
{
  "id": "act-regex-ops-as-nfa",
  "level": "2",
  "url": "regex.html#act-regex-ops-as-nfa",
  "type": "Activity",
  "number": "2.4.2",
  "title": "",
  "body": "  Draw an NFA for each regular expression over the alphabet . Remember that star has the highest precedence (must be evaluated first) and union ( ) the lowest. These are not trick questions.                 "
},
{
  "id": "activity-31",
  "level": "2",
  "url": "regex.html#activity-31",
  "type": "Activity",
  "number": "2.4.3",
  "title": "",
  "body": "  In this exercise, use -transitions as needed, but make sure your NFA have  a single start state with no incoming transitions  a single accept state with no outgoing transitions.                  "
},
{
  "id": "activity-32",
  "level": "2",
  "url": "regex.html#activity-32",
  "type": "Activity",
  "number": "2.4.4",
  "title": "",
  "body": "  Draw an NFA whose language is the same as the language matched by the regular expression. Don't try to do it all at once: Instead, proceed inductively, making simple NFA and then combining them as in .        "
},
{
  "id": "activity-33",
  "level": "2",
  "url": "regex.html#activity-33",
  "type": "Activity",
  "number": "2.4.5",
  "title": "",
  "body": "  Suppose you are given NFA and each having  a single start state with no incoming transitions  a single accept state with no outgoing transitions.  Explain how you would combine these into a new NFA satisfying . should also satisfy conditions 1 and 2 above. You are allowed to use -transitions and to respecify the start and accepting states.   "
},
{
  "id": "activity-34",
  "level": "2",
  "url": "regex.html#activity-34",
  "type": "Activity",
  "number": "2.4.6",
  "title": "",
  "body": "  Suppose you are given NFA and each having  a single start state with no incoming transitions  a single accept state with no outgoing transitions.  Explain how you would combine these into a new NFA satisfying . should also satisfy conditions 1 and 2 above. You are allowed to use -transitions and to respecify the start and accepting states.   "
},
{
  "id": "activity-35",
  "level": "2",
  "url": "regex.html#activity-35",
  "type": "Activity",
  "number": "2.4.7",
  "title": "",
  "body": "  Suppose you are given an NFA having  a single start state with no incoming transitions  a single accept state with no outgoing transitions.  Explain how you would use to build a new NFA satisfying . should also satisfy conditions 1 and 2 above. You are allowed to use -transitions and to respecify the start and accepting states.   "
},
{
  "id": "activity-36",
  "level": "2",
  "url": "regex.html#activity-36",
  "type": "Activity",
  "number": "2.4.8",
  "title": "",
  "body": "     Suppose we have an NFA with multiple accept states, some of which might have outgoing transitions. Explain how to use an -transition and a new accept state to convert it to an equivalent NFA with a single accept state and no outgoing transitions from the accept state.    Suppose we have a pseudo-NFA (multiple start states), some of which might have incoming transitions. Explain how to use an -transition and a new start state to convert it to an equivalent NFA with a single start state and no incoming transitions to the start state.      "
},
{
  "id": "activity-37",
  "level": "2",
  "url": "regex.html#activity-37",
  "type": "Activity",
  "number": "2.4.9",
  "title": "",
  "body": "  Use your answers to the previous activities to devise a proof that every regular expression can be simulated by an NFA. The definition of regular expression is inductive, so an inductive proof suggests itself.   "
},
{
  "id": "sec-pumping-lemma-regular",
  "level": "1",
  "url": "sec-pumping-lemma-regular.html",
  "type": "Section",
  "number": "2.5",
  "title": "Using the Pumping Lemma",
  "body": " Using the Pumping Lemma    Key Resources for the Pumping Lemma    Full proof    Quick proof    Two hours of examples       Class activities  Suppose that is a language we wish to prove is not regular, using the Pumping Lemma. The proof begins like this: If is regular, then the Pumping Lemma says it must have a pumping constant . The Pumping Lemma says that every word of length at least can be split into three parts, , where and , such that for all . We sometimes call a pumpable substring or even just a pump . The proof generally proceeds by finding a word that is in and that has no pumpable substring. This is a contradiction of the Pumping Lemma, and shows our assumption (that was regular) must be false.    Which of the following are true?  We get to choose a value for .  We get to choose a candidate word of length at least .  We get to choose the parts (that is, , , and ) in the decomposition .  We get to choose a value for .      Only and are true.    The pumping lemma does not relate the value of to the language . It only states that exists and has the specified properties. Given the length , we can choose any convenient word as long as . However, we have to examine all the decompositions, so we don't get to choose , , or . We only have to show that (for every choice of , , ) there is some value of such that , so we get to choose .      What is a good choice of for proving that each of the following languages is not regular?               A string of left brackets ( and right brackets ) is balanced if every left bracket has a matching right bracket. For example, () , (()) , and (())() are balanced, but )( , ())) , and ()((()) are not. What is a good choice of for proving that is not regular?    The balanced bracket languages play an important role in the structure theory of the Chomsky hierarchy, as we'll see later on. They are also connected to an interesting numerical sequence, the Catalan numbers . You can learn more about the Catalan numbers at . There are many diagrams there which I expect you will find entertaining.    Here are the first 8 languages proved non-regular in this video .                          Watch the video segment for the language of your choice. Then try to reproduce the proof without looking back. It's annoying to write proofs during class, but try. Work in groups of 4 or more (so I can be sure to see everyone's proof).    The last exercise in the needs a special trick. The reason is that even filling with 0s doesn't help. One trick that works is the so-called  -factorial trick .  We choose (still looking at the language ). Then as usual, and are all 0s. But notice that we must have . It follows that divides . So if we choose , then . Then . This completes the proof that is not regular.  The trick can be helpful when, as in the previous example, we find it harder to get out of the language than to stay in.   Use the pumping lemma to show that is not regular.  Here, we have to be quite sneaky. The first problem is that the pumping constant probably isn't prime, but even if it is we have no way of knowing that. So we have to rely on the fact that the set of primes is unbounded: there is a prime greater than any given number. So we can choose to be the smallest prime greater than and then choose . The reason for the will be clear soon.  Now is all zeroes, since is all zeroes. So is all zeroes. We need a value of such that is not prime. We cleverly let . Then . Now, because , we have . If , the proof is complete, because we have a factorization of into two numbers greater than 1. So we just have to show that . This is where the in comes in. We have , which is to say . We have to be careful with inequalities. But if we subtract from the left, we know we have reduced the left by at most (possibly less), so we may subtract from the right and the inequality will still hold. So we have , as required.    "
},
{
  "id": "list-key-resources-pumping-lemma-regular",
  "level": "2",
  "url": "sec-pumping-lemma-regular.html#list-key-resources-pumping-lemma-regular",
  "type": "List",
  "number": "2.5.1",
  "title": "Key Resources for the Pumping Lemma",
  "body": " Key Resources for the Pumping Lemma    Full proof    Quick proof    Two hours of examples    "
},
{
  "id": "p-263",
  "level": "2",
  "url": "sec-pumping-lemma-regular.html#p-263",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pumpable substring pump "
},
{
  "id": "activity-38",
  "level": "2",
  "url": "sec-pumping-lemma-regular.html#activity-38",
  "type": "Activity",
  "number": "2.5.1",
  "title": "",
  "body": "  Which of the following are true?  We get to choose a value for .  We get to choose a candidate word of length at least .  We get to choose the parts (that is, , , and ) in the decomposition .  We get to choose a value for .      Only and are true.    The pumping lemma does not relate the value of to the language . It only states that exists and has the specified properties. Given the length , we can choose any convenient word as long as . However, we have to examine all the decompositions, so we don't get to choose , , or . We only have to show that (for every choice of , , ) there is some value of such that , so we get to choose .   "
},
{
  "id": "activity-39",
  "level": "2",
  "url": "sec-pumping-lemma-regular.html#activity-39",
  "type": "Activity",
  "number": "2.5.2",
  "title": "",
  "body": "  What is a good choice of for proving that each of the following languages is not regular?            "
},
{
  "id": "activity-40",
  "level": "2",
  "url": "sec-pumping-lemma-regular.html#activity-40",
  "type": "Activity",
  "number": "2.5.3",
  "title": "",
  "body": "  A string of left brackets ( and right brackets ) is balanced if every left bracket has a matching right bracket. For example, () , (()) , and (())() are balanced, but )( , ())) , and ()((()) are not. What is a good choice of for proving that is not regular?   "
},
{
  "id": "act-pumping-lemma-first8",
  "level": "2",
  "url": "sec-pumping-lemma-regular.html#act-pumping-lemma-first8",
  "type": "Activity",
  "number": "2.5.4",
  "title": "",
  "body": "  Here are the first 8 languages proved non-regular in this video .                          Watch the video segment for the language of your choice. Then try to reproduce the proof without looking back. It's annoying to write proofs during class, but try. Work in groups of 4 or more (so I can be sure to see everyone's proof).   "
},
{
  "id": "example-5",
  "level": "2",
  "url": "sec-pumping-lemma-regular.html#example-5",
  "type": "Example",
  "number": "2.5.2",
  "title": "",
  "body": " Use the pumping lemma to show that is not regular.  Here, we have to be quite sneaky. The first problem is that the pumping constant probably isn't prime, but even if it is we have no way of knowing that. So we have to rely on the fact that the set of primes is unbounded: there is a prime greater than any given number. So we can choose to be the smallest prime greater than and then choose . The reason for the will be clear soon.  Now is all zeroes, since is all zeroes. So is all zeroes. We need a value of such that is not prime. We cleverly let . Then . Now, because , we have . If , the proof is complete, because we have a factorization of into two numbers greater than 1. So we just have to show that . This is where the in comes in. We have , which is to say . We have to be careful with inequalities. But if we subtract from the left, we know we have reduced the left by at most (possibly less), so we may subtract from the right and the inequality will still hold. So we have , as required.  "
},
{
  "id": "CFL-intro",
  "level": "1",
  "url": "CFL-intro.html",
  "type": "Section",
  "number": "3.1",
  "title": "Recursive inference, trees, and derivations",
  "body": " Recursive inference, trees, and derivations    Learn stuff    In class, we looked at the following example grammar and tried to write down a recursive inference table for the sentence .  shows one solution.   Recursive inference for .     String  Variable  Production  Strings used    1        2        3        4     1    5     2    6        7     4, 5, 6    8        9     8    10        11     7, 10, 9    12        13     12, 4    14     5, 10, 13    15     6, 14, 11     "
},
{
  "id": "objectives-5",
  "level": "2",
  "url": "CFL-intro.html#objectives-5",
  "type": "Objectives",
  "number": "3.1",
  "title": "",
  "body": "  Learn stuff   "
},
{
  "id": "table-recursive-inference-kozen",
  "level": "2",
  "url": "CFL-intro.html#table-recursive-inference-kozen",
  "type": "Table",
  "number": "3.1.1",
  "title": "Recursive inference for <span class=\"process-math\">\\((((P \\vee Q) \\wedge R) \\vee (Q \\wedge (\\neg P)))\\text{.}\\)<\/span>",
  "body": " Recursive inference for .     String  Variable  Production  Strings used    1        2        3        4     1    5     2    6        7     4, 5, 6    8        9     8    10        11     7, 10, 9    12        13     12, 4    14     5, 10, 13    15     6, 14, 11    "
},
{
  "id": "PDA-intro",
  "level": "1",
  "url": "PDA-intro.html",
  "type": "Section",
  "number": "3.2",
  "title": "Intro to pushdown automata",
  "body": " Intro to pushdown automata    Learn stuff     Informal definition  We imagine a pushdown automaton or PDA as being like an -NFA with a stack attached. We still use transitions to move from one state to another. Like -NFA, PDA are nondeterministic and can spontaneously transition without consuming input. This is not a big new idea.  On the other hand, the transition function for a PDA uses both the input word and the stack as part of the input. That is, the transitions that are available are determined in part by the contents of the stack as well as the remaining part of the input word.  Both -transitions and normal transitions have the chance to alter the stack on their way to the new state. A transition may:  Pop the top symbol off the stack (it vanishes forever)  Push one or more symbols onto the top of the stack  Both these alterations are optional, but if both occur, the pop is always first.  In the formal specification given in , you will see that the set of stack symbols is allowed to be different from the alphabet . In fact, it always is different, because we need a special start symbol that has no job but being the bottom of the stack.  Acceptance for PDA is somewhat like acceptance for NFA. PDA have a set of states designated as accepting states, and if there is a branch of the nondeterministic computation that lands in an accepting state when the input word is consumed, the word is said to be in the accepting-state language of the PDA. As the phrasing suggests, there is a second definition of acceptance that is postponed until HMU section 6.2. This is called empty-stack acceptance, and we will see it is quite natural.   For any particular PDA , the accepting-state language and the empty-stack language are typically different.      Formal specification  The formal specification of a PDA looks like this: . Here   is the set of states   is the alphabet (the input symbols)   is the set of stack symbols   is the transition function, explained in more detail below   is the initial state (we assume )   is the bottom stack symbol (we assume that )   is the set of accepting states (we assume that )  We usually don't give tables for the transition function, instead preferring lengthy verbal descriptions. The reason is that the domain is the product of three sets, namely and thus instead of a 2-d table of input values we have a 3-d cube of them.  Here are some useful figures. I'll add more explanation later.   (for accessibility)    (for accessibility    (for accessibility)     (This is Exercise 6.1.1 from HMU.) Suppose that is a PDA, and that is described by the following rules.    . This means that if in state , we read a and there is on the top of the stack, we can (and must) remain in state , consume the , do not pop, and push an on the stack. The pair represents the new state and the new stack top (read from top to bottom as we go left to right, so the is still there and the is on top of it).                                   Show all the reachable instantaneous descriptions when the input is:          "
},
{
  "id": "objectives-6",
  "level": "2",
  "url": "PDA-intro.html#objectives-6",
  "type": "Objectives",
  "number": "3.2",
  "title": "",
  "body": "  Learn stuff   "
},
{
  "id": "p-281",
  "level": "2",
  "url": "PDA-intro.html#p-281",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pushdown automaton stack "
},
{
  "id": "warning-1",
  "level": "2",
  "url": "PDA-intro.html#warning-1",
  "type": "Warning",
  "number": "3.2.1",
  "title": "",
  "body": " For any particular PDA , the accepting-state language and the empty-stack language are typically different.  "
},
{
  "id": "activity-42",
  "level": "2",
  "url": "PDA-intro.html#activity-42",
  "type": "Activity",
  "number": "3.2.1",
  "title": "",
  "body": "  (This is Exercise 6.1.1 from HMU.) Suppose that is a PDA, and that is described by the following rules.    . This means that if in state , we read a and there is on the top of the stack, we can (and must) remain in state , consume the , do not pop, and push an on the stack. The pair represents the new state and the new stack top (read from top to bottom as we go left to right, so the is still there and the is on top of it).                                   Show all the reachable instantaneous descriptions when the input is:        "
},
{
  "id": "sec-hw1",
  "level": "1",
  "url": "sec-hw1.html",
  "type": "Section",
  "number": "4.1",
  "title": "Homework 01",
  "body": " Homework 01  This assignment covers 2.1 and 2.2 in HMU. Each problem will be worth 3 checks. Your answers should be like little essays, made only of complete sentences. Formulas should never stand on their own, but should be parts of otherwise complete sentences. You should be able to read your answer aloud from beginning to end and have it sound sensible. If your solution is more like a pile of equations, with little or no connecting narration, you'll max out at 2 checks.    The following are the transition diagrams of two DFA and . Answer the following questions about each one.   What is the start state?  What is the set of accepting states?  What sequence of states does the machine go through on input aabb ?  Does the machine accept the string aabb ?  Does the machine accept the string ?           .         Translate the transition diagram in into a formal specification. Carefully list all of the components ( , , ).    The transition function of a DFA is given by the following table. Use the table to give a transition diagram for this machine.  NOTE. This problem was updated. Make sure you inspect the table carefully.                                      If is a language (a subset of ) then its complement is the language .  Show that if is a DFA that accepts language , then swapping the accept and nonaccept states in yields a DFA that accepts .   Start by supposing (your hypothesis) that a DFA has been given, and it accepts . That is to say, suppose is a DFA such that . Use this assumption and what you have learned about DFA to argue persuasively and in detail that when the states are swapped, the resulting machine accepts all words not in and rejects all words in . Since you don't have a transition diagram to fall back on, you'll need to use the formal description of the DFA in terms of sets and functions.  An earlier version of this Hint said that this isn't an induction proof. That was a little overeager. It is very possible to give a persuasive proof that doesn't use it, but I shouldn't have said you can't . In this particular case, though, I don't think the inductive argument is simpler or more convenient.    For any word , its reverse  is defined to be , so the symbols appear in the reverse order. Recall that a language is regular if it is accepted by some DFA. Show that if is a regular language, so is the language , where .   In the previous problem, a modification to the DFA was suggested: swap the accepting and non-accepting states. In this one, you will need to concoct the modification yourself, and give some of the details of why the resulting thing is a DFA.  Since you don't have a transition diagram to fall back on, you'll need to use the formal description of the DFA in terms of sets and functions. There are two things to prove: first, that contains all words where , and second, that does not contain any word that isn't the reverse of a word in .    "
},
{
  "id": "exercise-1",
  "level": "2",
  "url": "sec-hw1.html#exercise-1",
  "type": "Exercise",
  "number": "4.1.1",
  "title": "",
  "body": " The following are the transition diagrams of two DFA and . Answer the following questions about each one.   What is the start state?  What is the set of accepting states?  What sequence of states does the machine go through on input aabb ?  Does the machine accept the string aabb ?  Does the machine accept the string ?           .       "
},
{
  "id": "exercise-2",
  "level": "2",
  "url": "sec-hw1.html#exercise-2",
  "type": "Exercise",
  "number": "4.1.2",
  "title": "",
  "body": " Translate the transition diagram in into a formal specification. Carefully list all of the components ( , , ).  "
},
{
  "id": "exercise-3",
  "level": "2",
  "url": "sec-hw1.html#exercise-3",
  "type": "Exercise",
  "number": "4.1.3",
  "title": "",
  "body": " The transition function of a DFA is given by the following table. Use the table to give a transition diagram for this machine.  NOTE. This problem was updated. Make sure you inspect the table carefully.                                    "
},
{
  "id": "exercise-4",
  "level": "2",
  "url": "sec-hw1.html#exercise-4",
  "type": "Exercise",
  "number": "4.1.4",
  "title": "",
  "body": " If is a language (a subset of ) then its complement is the language .  Show that if is a DFA that accepts language , then swapping the accept and nonaccept states in yields a DFA that accepts .   Start by supposing (your hypothesis) that a DFA has been given, and it accepts . That is to say, suppose is a DFA such that . Use this assumption and what you have learned about DFA to argue persuasively and in detail that when the states are swapped, the resulting machine accepts all words not in and rejects all words in . Since you don't have a transition diagram to fall back on, you'll need to use the formal description of the DFA in terms of sets and functions.  An earlier version of this Hint said that this isn't an induction proof. That was a little overeager. It is very possible to give a persuasive proof that doesn't use it, but I shouldn't have said you can't . In this particular case, though, I don't think the inductive argument is simpler or more convenient.  "
},
{
  "id": "exercise-5",
  "level": "2",
  "url": "sec-hw1.html#exercise-5",
  "type": "Exercise",
  "number": "4.1.5",
  "title": "",
  "body": " For any word , its reverse  is defined to be , so the symbols appear in the reverse order. Recall that a language is regular if it is accepted by some DFA. Show that if is a regular language, so is the language , where .   In the previous problem, a modification to the DFA was suggested: swap the accepting and non-accepting states. In this one, you will need to concoct the modification yourself, and give some of the details of why the resulting thing is a DFA.  Since you don't have a transition diagram to fall back on, you'll need to use the formal description of the DFA in terms of sets and functions. There are two things to prove: first, that contains all words where , and second, that does not contain any word that isn't the reverse of a word in .  "
},
{
  "id": "sec-hw2",
  "level": "1",
  "url": "sec-hw2.html",
  "type": "Section",
  "number": "4.2",
  "title": "Homework 02",
  "body": " Homework 02  This assignment covers sections 2.3 through 2.5 in HMU. Each problem will be worth 3 checks. Your answers should be like little essays, made only of complete sentences. Formulas should never stand on their own, but should be parts of otherwise complete sentences. You should be able to read your answer aloud from beginning to end and have it sound sensible. If your solution is more like a pile of equations, with little or no connecting narration, you'll max out at 2 checks.    Each of the following languages is the complement of a simpler language. In each part, construct an NFA for the simpler language, then use it to give the state diagram of an NFA for the language given. In all parts, .          Refer to for an idea on how to handle the complementation.    Each of the languages below is the concatenation of two simpler languages. The concatenation of languages and is the language . For each language, give a single -NFA that accepts it. The language is always .   Zero or more followed by zero or more  A string of odd length followed by a string ending in  Any string except a single or    Solve two simpler problems first, then use an to connect them.    Use the subset construction to convert the NFA below into a DFA. Give both a transition table including all the states (even the inaccessible ones) and a state diagram showing only the accessible states. The alphabet is .       For each of the following regular expressions, give two strings that match and two that do not match. The alphabet is .          Give NFA that accept the languages that match the regular expressions.        "
},
{
  "id": "exercise-6",
  "level": "2",
  "url": "sec-hw2.html#exercise-6",
  "type": "Exercise",
  "number": "4.2.1",
  "title": "",
  "body": " Each of the following languages is the complement of a simpler language. In each part, construct an NFA for the simpler language, then use it to give the state diagram of an NFA for the language given. In all parts, .          Refer to for an idea on how to handle the complementation.  "
},
{
  "id": "exercise-7",
  "level": "2",
  "url": "sec-hw2.html#exercise-7",
  "type": "Exercise",
  "number": "4.2.2",
  "title": "",
  "body": " Each of the languages below is the concatenation of two simpler languages. The concatenation of languages and is the language . For each language, give a single -NFA that accepts it. The language is always .   Zero or more followed by zero or more  A string of odd length followed by a string ending in  Any string except a single or    Solve two simpler problems first, then use an to connect them.  "
},
{
  "id": "exercise-8",
  "level": "2",
  "url": "sec-hw2.html#exercise-8",
  "type": "Exercise",
  "number": "4.2.3",
  "title": "",
  "body": " Use the subset construction to convert the NFA below into a DFA. Give both a transition table including all the states (even the inaccessible ones) and a state diagram showing only the accessible states. The alphabet is .     "
},
{
  "id": "exercise-9",
  "level": "2",
  "url": "sec-hw2.html#exercise-9",
  "type": "Exercise",
  "number": "4.2.4",
  "title": "",
  "body": " For each of the following regular expressions, give two strings that match and two that do not match. The alphabet is .        "
},
{
  "id": "exercise-10",
  "level": "2",
  "url": "sec-hw2.html#exercise-10",
  "type": "Exercise",
  "number": "4.2.5",
  "title": "",
  "body": " Give NFA that accept the languages that match the regular expressions.      "
},
{
  "id": "sec-hw3",
  "level": "1",
  "url": "sec-hw3.html",
  "type": "Section",
  "number": "4.3",
  "title": "Homework 03",
  "body": " Homework 03  This assignment covers sections 2.5 through 3.2 in HMU. Each problem will be worth 3 checks. Your code should be like floating little poems. Use comments wisely: don't explain the routine things, but the clever ones. Make your code transparent so that it is easy to read and understand.  The assignment is worth 15 checks.    Write a single Python file dfa.py that implements the classes specified below with the indicated behavior. You may use any Python features you like, but you may not use any other modules (imports). You are explicitly instructed not to search for a solution to this problem. Obviously it will be very easy to find. Instead, use what you know from class and your existing programming skills. All the code you submit should be your own. Please also refrain from the use of any type of programming assistant (turn off AI gizmos like GitHub Copilot, IntelliSense, ).  Keep the following philosophy in mind as you code. The intuitive, diagram-based idea of a DFA is not something easy to code. However, you also have access to the formal specification and much surrounding apparatus. I would suggest implementing DFA in terms of the formal specification: use it as your inspiration for how the class's fields should look.   The class DFA . This class should have the following methods:  a constructor that returns a usable DFA object  a __repr__() method that dumps the current formal specification of the DFA to the output  a run() method that simulates the action of the extended transition function (see ). This method should return a bool whose value indicates acceptance or rejection.  I have not specified the parameters. These are all instance methods of the class, so must take at least the parameter self . The DFA is nothing more than its formal specification, so you can start there.   Use the data type set for , , and . Think about Python's types carefully before you choose how to implement .   The class NFA . This class should have the following methods. My remarks above about the parameters apply here as well.  a constructor that returns a usable NFA object  a __repr__() method that dumps the current formal specification of the NFA to the output  a helper method do_delta() that simulates the (non-extended) transition function . This method should handle missing transitions gracefully, since it is for an NFA.  a run() method that simulates the action of the extended transition function (see ). This method should call the do_delta() method. It should return a bool whose value indicates acceptance or rejection.     Add another method to your DFA class. The method NFA() takes a DFA object as parameter and should return an instance of your NFA class that is equivalent to the passed DFA.   Also add a method DFA() to your NFA class. This method will perform the subset construction on the passed NFA, and return a DFA instance representing the DFA so constructed.   This part is difficult to get working for all NFA. Obviously, the first difficulty here is the transition function. Be sure you are familiar with the available methods that belong to the classes you have chosen. You may need to use Python's frozenset type, which behaves like a set but is immutable. If you need to build a frozenset element by element, start with a normal set, and then convert when you are done.  Another difficulty is constructing the power set. I recommend an iterative approach, although you can use recursion too. My preferred method is to use the natural correspondence between the elements of the power set and the binary representations of the integers from 0 to . Imagine that the states of are numbered from to . Then the th element of the power set contains the th element of if and only if the binary representation of has a 1 in the -th position.   def powerset(elems):  \"\"\"Returns a set representing the power set of `elems`.  Note that this can be very expensive (time and space)  since the size of the power set is exponential in the  size of `elems`.\"\"\"   elems_list = list(elems) # need to use indexing  n = len(elems)  powerset_size = 2**n  result = set()  for i in range(powerset_size):  # item j from elems is in the ith element  # of the powerset if the binary rep of i  # has a 1 in position j  ith_subset = set()  for j in range(n):  if (i & (1 << j) > 0):  ith_subset.add(elems_list[j])  result.add(frozenset(ith_subset))  return result   Finally, it is convenient to have access to the product function to form the Cartesian product . The function itertools.product is available for this purpose. Try the following code in the Python console:   import itertools  Q = {1, 2, 3}  Sigma = {'a', 'b'}  for q, a in itertools.product(Q, Sigma):  print(q, a)  1 a 1 b 2 a 2 b 3 a 3 b    The remaining 3 checks are allocated based on the quality and style of your code.    "
},
{
  "id": "ex-implement-dfa",
  "level": "2",
  "url": "sec-hw3.html#ex-implement-dfa",
  "type": "Exercise",
  "number": "4.3.1",
  "title": "",
  "body": " Write a single Python file dfa.py that implements the classes specified below with the indicated behavior. You may use any Python features you like, but you may not use any other modules (imports). You are explicitly instructed not to search for a solution to this problem. Obviously it will be very easy to find. Instead, use what you know from class and your existing programming skills. All the code you submit should be your own. Please also refrain from the use of any type of programming assistant (turn off AI gizmos like GitHub Copilot, IntelliSense, ).  Keep the following philosophy in mind as you code. The intuitive, diagram-based idea of a DFA is not something easy to code. However, you also have access to the formal specification and much surrounding apparatus. I would suggest implementing DFA in terms of the formal specification: use it as your inspiration for how the class's fields should look.   The class DFA . This class should have the following methods:  a constructor that returns a usable DFA object  a __repr__() method that dumps the current formal specification of the DFA to the output  a run() method that simulates the action of the extended transition function (see ). This method should return a bool whose value indicates acceptance or rejection.  I have not specified the parameters. These are all instance methods of the class, so must take at least the parameter self . The DFA is nothing more than its formal specification, so you can start there.   Use the data type set for , , and . Think about Python's types carefully before you choose how to implement .   The class NFA . This class should have the following methods. My remarks above about the parameters apply here as well.  a constructor that returns a usable NFA object  a __repr__() method that dumps the current formal specification of the NFA to the output  a helper method do_delta() that simulates the (non-extended) transition function . This method should handle missing transitions gracefully, since it is for an NFA.  a run() method that simulates the action of the extended transition function (see ). This method should call the do_delta() method. It should return a bool whose value indicates acceptance or rejection.     Add another method to your DFA class. The method NFA() takes a DFA object as parameter and should return an instance of your NFA class that is equivalent to the passed DFA.   Also add a method DFA() to your NFA class. This method will perform the subset construction on the passed NFA, and return a DFA instance representing the DFA so constructed.   This part is difficult to get working for all NFA. Obviously, the first difficulty here is the transition function. Be sure you are familiar with the available methods that belong to the classes you have chosen. You may need to use Python's frozenset type, which behaves like a set but is immutable. If you need to build a frozenset element by element, start with a normal set, and then convert when you are done.  Another difficulty is constructing the power set. I recommend an iterative approach, although you can use recursion too. My preferred method is to use the natural correspondence between the elements of the power set and the binary representations of the integers from 0 to . Imagine that the states of are numbered from to . Then the th element of the power set contains the th element of if and only if the binary representation of has a 1 in the -th position.   def powerset(elems):  \"\"\"Returns a set representing the power set of `elems`.  Note that this can be very expensive (time and space)  since the size of the power set is exponential in the  size of `elems`.\"\"\"   elems_list = list(elems) # need to use indexing  n = len(elems)  powerset_size = 2**n  result = set()  for i in range(powerset_size):  # item j from elems is in the ith element  # of the powerset if the binary rep of i  # has a 1 in position j  ith_subset = set()  for j in range(n):  if (i & (1 << j) > 0):  ith_subset.add(elems_list[j])  result.add(frozenset(ith_subset))  return result   Finally, it is convenient to have access to the product function to form the Cartesian product . The function itertools.product is available for this purpose. Try the following code in the Python console:   import itertools  Q = {1, 2, 3}  Sigma = {'a', 'b'}  for q, a in itertools.product(Q, Sigma):  print(q, a)  1 a 1 b 2 a 2 b 3 a 3 b    The remaining 3 checks are allocated based on the quality and style of your code.  "
},
{
  "id": "sec-hw4",
  "level": "1",
  "url": "sec-hw4.html",
  "type": "Section",
  "number": "4.4",
  "title": "Homework 04",
  "body": " Homework 04  This assignment covers 5.1 and 5.2 in HMU. Each problem will be worth 3 checks (unless otherwise noted). Your answers should be like little essays, made only of complete sentences. Formulas should never stand on their own, but should be parts of otherwise complete sentences. You should be able to read your answer aloud from beginning to end and have it sound sensible. If your solution is more like a pile of equations, with little or no connecting narration, you'll max out at 2 checks.     Parts are worth 3 checks each. Complete Part for an additional 3 bonus checks.  Consider the following grammar: .   Write down a recursive inference table giving at least four strings of length at least that are in the language of .   Write down either leftmost or rightmost derivations giving at least four strings of length at least that are in the language of .   Use either leftmost derivations or recursive inference to find at least four strings of length at least that are in , and make a conjecture about which strings are in the language of the above grammar.   Prove that your conjecture from Part is correct.    Let . We may think of as the set of symbols used by regular expressions over alphabet . The only difference is that we use for symbol , to avoid potential confusion with the actual that may appear in your grammar productions. Design a CFG with set of terminals that generates exactly the regular expressions with alphabet .  This problem originally left out the symbol. Both the and should be there, but the is binary operator for regular expression union, not the unary operator denoting one or more .    Describe, in general terms, a recursive method to convert a regular expression to an equivalent context-free grammar. You do not need to prove that your method is correct.   General here does not mean vague , but rather that your explanation is not tied to a specific example. Try to be general and precise at once. The reader should understand how to write down productions for the grammar based on your solution and the form of the regular expression.   Use the recursive definition of a regular expression. That is, explain how to handle the base cases directly and give a general explanation of how to handle the recursive cases.    Each part of this problem is worth 3 checks.  A context-free grammar is said to be right-linear if each production body has at most one variable, and that variable is at the right end. That is, all productions of a right-linear grammar are of the form or , where and are variables and a string of zero or more terminals.   In the same sense as , give a general method to convert a right-linear grammar to an -NFA. This shows that right-linear grammars are at least as powerful as -NFAs (equivalently, DFAs, regular expressions, etc.)   Construct an -NFA that simulates leftmost derivations, using its state to represent the lone variable in the current left-sentential form.   Give a general method for converting a DFA into a right-linear grammar. Combined with the previous part, this shows that right-linear grammars recognize exactly the regular languages.   Start with a DFA and let the variables of the grammar represent states.    For each string below, find a parse tree that shows how it is generated by the grammar.          "
},
{
  "id": "exercise-12",
  "level": "2",
  "url": "sec-hw4.html#exercise-12",
  "type": "Exercise",
  "number": "4.4.1",
  "title": "",
  "body": "  Parts are worth 3 checks each. Complete Part for an additional 3 bonus checks.  Consider the following grammar: .   Write down a recursive inference table giving at least four strings of length at least that are in the language of .   Write down either leftmost or rightmost derivations giving at least four strings of length at least that are in the language of .   Use either leftmost derivations or recursive inference to find at least four strings of length at least that are in , and make a conjecture about which strings are in the language of the above grammar.   Prove that your conjecture from Part is correct.  "
},
{
  "id": "exercise-13",
  "level": "2",
  "url": "sec-hw4.html#exercise-13",
  "type": "Exercise",
  "number": "4.4.2",
  "title": "",
  "body": " Let . We may think of as the set of symbols used by regular expressions over alphabet . The only difference is that we use for symbol , to avoid potential confusion with the actual that may appear in your grammar productions. Design a CFG with set of terminals that generates exactly the regular expressions with alphabet .  This problem originally left out the symbol. Both the and should be there, but the is binary operator for regular expression union, not the unary operator denoting one or more .  "
},
{
  "id": "hw04-exer-regex-to-cfg",
  "level": "2",
  "url": "sec-hw4.html#hw04-exer-regex-to-cfg",
  "type": "Exercise",
  "number": "4.4.3",
  "title": "",
  "body": " Describe, in general terms, a recursive method to convert a regular expression to an equivalent context-free grammar. You do not need to prove that your method is correct.   General here does not mean vague , but rather that your explanation is not tied to a specific example. Try to be general and precise at once. The reader should understand how to write down productions for the grammar based on your solution and the form of the regular expression.   Use the recursive definition of a regular expression. That is, explain how to handle the base cases directly and give a general explanation of how to handle the recursive cases.  "
},
{
  "id": "exercise-15",
  "level": "2",
  "url": "sec-hw4.html#exercise-15",
  "type": "Exercise",
  "number": "4.4.4",
  "title": "",
  "body": " Each part of this problem is worth 3 checks.  A context-free grammar is said to be right-linear if each production body has at most one variable, and that variable is at the right end. That is, all productions of a right-linear grammar are of the form or , where and are variables and a string of zero or more terminals.   In the same sense as , give a general method to convert a right-linear grammar to an -NFA. This shows that right-linear grammars are at least as powerful as -NFAs (equivalently, DFAs, regular expressions, etc.)   Construct an -NFA that simulates leftmost derivations, using its state to represent the lone variable in the current left-sentential form.   Give a general method for converting a DFA into a right-linear grammar. Combined with the previous part, this shows that right-linear grammars recognize exactly the regular languages.   Start with a DFA and let the variables of the grammar represent states.  "
},
{
  "id": "exercise-16",
  "level": "2",
  "url": "sec-hw4.html#exercise-16",
  "type": "Exercise",
  "number": "4.4.5",
  "title": "",
  "body": " For each string below, find a parse tree that shows how it is generated by the grammar.        "
}
]

var ptx_lunr_idx = lunr(function () {
  this.ref('id')
  this.field('title')
  this.field('body')
  this.metadataWhitelist = ['position']

  ptx_lunr_docs.forEach(function (doc) {
    this.add(doc)
  }, this)
})
