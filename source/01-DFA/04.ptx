<?xml version='1.0' encoding='utf-8'?>
<section xml:id="regex" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Regular expressions</title>
  <introduction>
    <p>
      Regular expressions are yet another way of describing the
      class of regular languages. We build them up from simpler
      ones using operations. It is more algebraic in feel than the
      state diagrams and automata.
    </p>
    <p>
      Regular expressions find wide use throughout computing in
      text matching applications. My standard zoo of examples includes
      the venerable UNIX/Linux utilities <c>grep</c>, <c>sed</c>, and
      <c>awk</c>. These are all based on regular expressions. They are
      also provided in every modern code editor and IDE, usually with
      extensions that go beyond the regular languages. Regular expressions
      find their way into these tools because their algebraic representation
      makes them easy to manipulate and combine and type into a terminal.
    </p>
    <p>
      Alumni of CSC-235 will perhaps recognize regular expressions from
      the homework we did involving <c>flex</c> and <c>bison</c>. It is
      typical for the lexing phase of a compiler to be implemented using
      regular expressions.
    </p>
  </introduction>
  <subsection xml:id="regex-basics">
    <title>Operators and examples</title>
    <p>

      Regular expressions denote languages. For example, <m>0\aster{1} +
      1\aster{0}</m> denotes the language whose words are strings of any number
      of <m>0</m> followed by a <m>1</m> or strings of any number of <m>1</m>
      followed by a single <m>0</m>. All the operators and rules for interpreting
      regular expressions are explained below and more exhaustively in HMU 3.1.
      The operators are listed below, in order of decreasing precedence,
      in <xref ref="list-regex-ops"/>. The description refers to languages,
      not regular expressions, but the operators and their meanings and notations
      will be the same.

    </p>
    <list xml:id="list-regex-ops">
      <title>Operators for languages</title>
      <dl>
        <li>
          <title>Union</title>
          <p>

            The union of the languages <m>L_1</m> and <m>L_2</m> is written
            <m>L_1 + L_2</m>. It contains all the words that are in either
            <m>L_1</m> or <m>L_2</m>.

          </p>
        </li>
        <li>
          <title>Concatenation</title>
          <p>

            The concatenation <m>L_1 L_2</m> of two languages consists of the
            words <m>w = xy</m> where <m>x</m> matches <m>L_1</m> and <m>y</m>
            matches <m>L_2</m>. Notice that only one such decomposition is
            required to exist: if it's possible to decompose <m>w</m> this way,
            it is in <m>L_1 L_2</m>. As you see, the concatenation operator is
            usually not represented by an explicit symbol, but by
            juxtaposition. We frequently use powers to stand for
            self-concatenation. So, <m>L^2</m> would be the same as <m>L L</m>,
            and <m>L^3</m> would be the same as <m>L L L = L^2 L = L L^2</m>,
            and so on. Using this convention, we have <m>L^0 = \{\epsilon\}</m>
            and <m>L^1 = L</m> for all languages <m>L</m>.

          </p>
        </li>
        <li>
          <title>Star</title>
          <p>

            The star operator represents the set of words formed from
            zero or more concatenations of the language to which
            it is applied. For example, <m>\aster{L}</m> denotes the set
            of strings obtaining by pasting zero or more strings from
            <m>L</m> together. Another way to say it is:<me>
              \aster{L} = L^0 + L^1 + L^2 + \cdots
            </me>
            where the powers represent self-concatenation.

          </p>
        </li>
      </dl>
    </list>
    <example xml:id="ex-kleene-star">
      <p>

        Example 3.1 in HMU is worth consulting. For a given language
        <m>L</m>, it is not always so obvious what <m>\aster{L}</m>
        is.

      </p>
    </example>
    <p>

      In the algebra of regular expressions, we use the same operators
      to combine simpler expressions. Each regular expression has a
      language that it <term>represents</term>. The language of a
      regular expression <m>E</m> is denoted <m>L(E)</m>, just like for
      automata.

    </p>
    <definition xml:id="def-regex">
      <statement>
        <p>

          The definition is inductive. Let the alphabet of symbols be some set
          <m>\Sigma</m>. Then

        </p>
        <ol>
          <li>
            <p>

              The constants <m>\varepsilon</m> and <m>\varnothing</m> are
              regular expressions. We define <m>L(\varepsilon) = \{\varepsilon\}</m>
              and <m>L(\varnothing) = \varnothing</m>.

            </p>
          </li>
          <li>
            <p>

              If <m>a \in \Sigma</m>, then <m>a</m> is a regular expression
              and <m>L(a) = \{a\}</m>.

            </p>
          </li>
          <li>
            <p>

              A variable, usually capitalized like <m>B</m>, is a
              regular expression. Such a variable represents a whole
              language.

            </p>
          </li>
          <li>
            <p>

              If <m>E</m> and <m>F</m> are regular expressions, then
              so is their union <m>E + F</m>. The language it
              represents is <m>L(E) + L(F)</m>.

            </p>
          </li>
          <li>
            <p>

              If <m>E</m> and <m>F</m> are regular expressions, then
              so is their concatenation <m>E F</m>. The language it
              represents is <m>L(E) L(F)</m>.

            </p>
          </li>
          <li>
            <p>

              If <m>E</m> is a regular expression, then
              so is its star <m>\aster{E}</m>. The language it
              represents is <m>\aster{L(E)}</m>.

            </p>
          </li>
          <li>
            <p>

              Finally, if <m>E</m> is a regular expression, then
              so is its parenthesization <m>(E)</m>. The language it
              represents is <m>L(E)</m>.

            </p>
          </li>
        </ol>
        <p>

          It is typical to also include the unary plus operator for regular
          expressions, but it is not necessary. We define <m>L^+</m> to
          be <m>LL^*</m>. This is the set of strings that can be formed
          by concatenating one or more strings from <m>L</m> (not zero
          or more).

        </p>
        <p>

          Note that it is very common to conflate a regular expression
          with the language it represents, especially when speaking.
          We should try to be clear and keep them separate at first.

        </p>
      </statement>
    </definition>
    <activity>
      <prelude>
        <p>
          Write regular expressions for each language.
        </p>
      </prelude>
      <task>
        <statement>
          <p>
            The set of strings over <m>\{a, b, c}</m> containing at least one <m>a</m> and one <m>b</m>
          </p>
        </statement>
        <answer>
          One that works is <me>
            (a + b + c)^* a (a + b + c)^* b (a + b + c)^*
              + (a + b + c)^* b (a + b + c)^* a (a + b + c)^*
          </me>.
        </answer>
      </task>
      <task>
        <statement>
          <p>
            The set of strings of <m>0</m>s and <m>1</m>s with no consecutive <m>1</m>s.
          </p>
        </statement>
        <answer>
          <p>
            <me>
              (0 + \varepsilon) (0 + 10)^* (0 + \varepsilon)
            </me>
          </p>
        </answer>
      </task>
      <task>
        <statement>
          <p>

          </p>
        </statement>
        <answer>
          <p>

          </p>
        </answer>
      </task>
    </activity>
  </subsection>
</section>
